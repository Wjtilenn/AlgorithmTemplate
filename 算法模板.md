# <center>算法模板</center>  

## <center>[字符串](#1)</center>
- [KMP算法](#1.1)
- [最小表示法](#1.2)
- [Manacher算法](#1.3)
- [字符串哈希](#1.4)
- [AC自动机](#1.5)
- [回文自动机](#1.6)
- [后缀数组](#1.7)
## <center>[数据结构](#2)</center>
- [ST表](#2.1)
- [并查集](#2.2)
- [树状数组](#2.3)
- [线段树](#2.4)
- [可持久化数据结构](#2.5)
- [平衡树](#2.6)
## <center>[图论](#3)</center>
- [单源最短路](#3.1)
- [全源最短路](#3.2)
- [二分图](#3.3)
- [图的连通性相关](#3.4)
- [网络流](#3.5)
- [树链剖分](#3.6)
- [斯坦纳树](#3.7)
- [2-SAT](#3.8)
## <center>[数学](#4)</center>
- [取模类](#4.1)
- [组合数](#4.2)
- [复数类](#4.3)
- [矩阵类](#4.4)
- [数论](#4.5)
- [组合数学](#4.6)
- [多项式](#4.7)
- [线性基](#4.8)
- [博弈论](#4.9)
- [其他](#4.10)

## <center>[计算几何](#5)</center>
- [计算几何模板](#5.1)
- [旋转卡壳](#5.2)

## <center>[杂项](#6)</center>
- [莫队](#6.1) 
- [CDQ分治](#6.2)
- [闵可夫斯基和优化dp](#6.3)
<div STYLE="page-break-after: always;"></div>

## <div id = "1"><center>字符串</center><div>
### <div id = "1.1">KMP算法<div>
- $\pi[i]$ 表示 $s[0,i]$ 中前缀与真后缀相等的最长长度
- 对字符串 $s$ 和 $0 < p \le |s|$，若 $s[i] = s[i + p]$ 对所有 $i \in [0, |s| - p - 1]$ 成立，则称 $p$ 是 $s$ 的周期。
$s$ 所有的周期，即 $n - \pi[n - 1] - 1,n - \pi[\pi[n - 1]] - 1, \ldots。$
- 每个前缀的出现次数
```C++
for(int i = 0;i < n;i++)if(kmp.ne[i] != -1)dp[kmp.ne[i]]++;
for(int i = n - 1;i >= 0;i--)if(kmp.ne[i] != -1)dp[kmp.ne[i]] += dp[i];
for(int i = 0;i < n;i++)dp[i]++;
```
```C++
struct KMP{
    int n;
    string p;
    vector<int> ne;
    KMP(){}
    KMP(string &s){init(s);}
    void init(string &s){
        n = s.size();
        p = s;
        ne.resize(n);
        ne[0] = -1;
        for(int i = 1,j = -1;i < n;i++){
            while(j != -1 && p[i] != p[j + 1])j = ne[j];
            if(p[i] == p[j + 1])j++;
            ne[i] = j;
        }
    }
    vector<int> match(string &s){
        int m = s.size();
        vector<int> res;
        for(int i = 0,j = -1;i < m;i++){
            while(j != -1 && s[i] != p[j + 1])j = ne[j];
            if(s[i] == p[j + 1])j++;
            if(j == n - 1)res.push_back(i - n + 1),j = ne[j];
        }
        return res;
    }
};
```

### <div id = "1.2">最小表示法<div>
- $当字符串S中选定一个位置i满足S[i,n]+S[1,i-1]=T，则称S与T循环同构$
- 字符串S的最小表示为S的循环同构串中字典序最小的字符串
```C++
string get_min(string s){
    int n = s.size();
    s = s + s,s = " " + s;
    int i = 1,j = 2,k = 0;
    while(i <= n && j <= n){
        for(k = 0;k < n && s[i + k] == s[j + k];k++);
        s[i + k] > s[j + k] ? i = i + k + 1 : j = j + k + 1;
        if(i == j)j++;
    }
    i = min(i,j);
    string res = s.substr(i,n - i + 1) + s.substr(1,i - 1);
    return res;
}
```

### <div id = "1.3">Manacher算法<div>
- $求最长回文串$
$r[i] - 1$表示以$i$为中心长度最长的回文串
$r[l + r] - 1 \ge r - l + 1$判断子串$(l,r)$是回文串
```C++
vector<int> manacher(string _s){
    int n = _s.size(),res = 0;
    string s;
    s += "$#";
    for(int i = 0;i < n;i++){
        s += _s[i];
        s += "#";
    }
    n = n * 2 + 1;
    vector<int> r(n + 1);
    for(int i = 1,idx = 0;i <= n;i++){
        if(idx + r[idx] - 1 >= i){
            r[i] = min(r[idx - i + idx],idx + r[idx] - i);
        }
        while(i + r[i] <= n && s[i - r[i]] == s[i + r[i]])r[i]++;
        if(i + r[i] > idx + r[idx])idx = i;
    }
    return r;
}
```

### <div id = "1.4">字符串哈希<div>
```C++
struct String_Hash{
    typedef unsigned long long ULL;
    static const ULL P = 1145141919180ULL,mod = (1ULL << 61) - 1;
    static int N;
    static vector<ULL> p;
    int n;
    vector<ULL> h;
    String_Hash(string s = ""){init(s);}
    static inline ULL add(ULL a,ULL b){
        ULL c = a + b;
        if(c >= mod)c -= mod;
        return c;
    }
    static inline ULL mul(ULL a, ULL b){
        __int128 c = __int128(a) * b;
        return add(c >> 61,c & mod);
    }
    ULL init(string s){
        n = (int)s.size() - 1;
        if(N < n){
            p.resize(n + 1);
            for(int i = N + 1;i <= n;i++){
                p[i] = mul(p[i - 1],P);
            }
            N = n;
        }
        h.resize(n + 1);
        for(int i = 1;i <= n;i++){
            h[i] = add(mul(h[i - 1],P),s[i]);
        }
        return h[n];
    }
    ULL find(int l,int r){
        return add(h[r],(mod - mul(h[l - 1],p[r - l + 1])));
    }
};
int String_Hash::N = 0;
vector<unsigned long long> String_Hash::p = {1};
```

### <div id = "1.5">AC自动机<div>
- BFS构建AC自动机：
1. 初始化，把根的儿子入队。
2. 只要队列不空，节点$u$出队，枚举节点$u$的所有儿子。
3. 若儿子存在，则父亲帮儿子建回跳边，儿子入队。若儿子不存在，则父亲自建转移边。
- 查找模式串出现次数
1. 扫面主串，以此取出字符$s_i$，指针$p$沿着树边或转移边边走，保证不回退。
2. 指针$j$沿着回跳边搜素模式串，每次从当前节点走到根节点，把当前节点所有模式串全部统计，保证不漏解。
```C++
struct AhoCorasick{
    static constexpr int M = 26;
    static constexpr int offset = 'a';
    struct Node{
        int cnt;
        int fail;
        array<int,M> next;
        Node() : fail(0),cnt(0),next{} {}
    };
    vector<Node> tr;
    AhoCorasick(){
        init();
    }
    void init(){
        tr.assign(1,Node());
    }
    int newNode(){
        tr.emplace_back();
        return tr.size() - 1;
    }
    void insert(const string &s){
        int p = 0;
        for(int i = 0;i < s.size();i++){
            if(!tr[p].next[s[i] - offset])tr[p].next[s[i] - offset] = newNode();
            p = tr[p].next[s[i] - offset];
        }
        tr[p].cnt++;
    }
    void build(){
        queue<int> q;
        for(int i = 0;i < M;i++){
            if(tr[0].next[i])q.push(tr[0].next[i]);
        }
        while(q.size()){
            int u = q.front();
            q.pop();
            for(int j = 0;j < M;j++){
                int v = tr[u].next[j];
                if(v){
                    tr[v].fail = tr[tr[u].fail].next[j];
                    q.push(v);
                }else{
                    tr[u].next[j] = tr[tr[u].fail].next[j];
                }
            }
        }
    }
    
    int work(const string &s){
        int res = 0;
        for(int i = 0,p = 0;i < s.size();i++){
            p = tr[p].next[s[i] - offset];
            for(int j = p;j && ~tr[j].cnt;j = tr[j].fail){
                res += tr[j].cnt;
                tr[j].cnt = -1;
            }
        }
        return res;
    }

};
```

### <div id = "1.6">回文自动机<div>
- 引理$1.1$：一个回文串 $S$ 的 $border$ 必定是一个回文串。
- 引理$1.2$：一个回文串 $S$ 的所有回文后缀必定是它的  $border$。
- 引理$2$：对于一个字符串 $S$，它本质不同的回文子串一定是以某个点结尾的、最长的那个回文串。
- 引理$3$：$S$ 的本质不同的回文子串个数不超过 $n$ 个。
```C++
struct PAM {
    static constexpr int M = 26;
    static constexpr int offset = 'a';
    struct Node {
        int fail,len,cnt;
        array<int, M> next;
        Node() : len(0),fail(0),cnt(0),next{} {}
    };
    std::vector<Node> tr;
    int suff;
    std::string s;
    PAM(){
        init();
    }
    void init(){
        tr.assign(2,Node());
        tr[0].fail = 1;
        tr[1].len = -1;
        suff = 0;
        s.clear();
    }
    int newNode() {
        tr.emplace_back();
        return tr.size() - 1;
    }
     
    bool insert(char c){
        int pos = s.size();
        s += c;
        int cur = suff;
        while(pos - 1 - tr[cur].len < 0 || s[pos - 1 - tr[cur].len] != s[pos]){
            cur = tr[cur].fail;
        }

        if(tr[cur].next[c - offset]){
            suff = tr[cur].next[c - offset];
            return false;
        }

        int idx = newNode(),tmp = cur;
        do{
            tmp = tr[tmp].fail;
        }while(pos - 1 - tr[tmp].len < 0 || s[pos - 1 - tr[tmp].len] != s[pos]);
        tr[idx].len = tr[cur].len + 2;
        tr[idx].fail = tr[tmp].next[c - offset];
        tr[idx].cnt = tr[tr[idx].fail].cnt + 1;
        tr[cur].next[c - offset] = idx;
        suff = idx;
        return true;
    }
};
```

### <div id = "1.7">后缀数组<div>
- $sa[i]$ : 排名为 $i$ 的后缀
- $rk[i]$ : 后缀 $i$ 的排名
```C++
struct SuffixArray{
    int n;
    vector<int> sa,rk;
    SuffixArray(string s){
        n = s.size() - 1;
        sa.resize(n + 1);
        rk.resize(n + 1);
        iota(sa.begin() + 1,sa.end(), 1);
        sort(sa.begin() + 1,sa.end(),[&](int i,int j)->bool{
            return s[i] < s[j];
        });
        rk[sa[1]] = 1;
        for(int i = 2;i <= n;i++){
            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);
        }
        int k = 1;
        vector<int> tmp(n + 1),cnt(n + 1);
        while(rk[sa[n]] < n){
            int cur = 0;
            for(int i = 1;i <= k;i++){
                tmp[++cur] = n - k + i;
            }
            for(int i = 1;i <= n;i++){
                if(sa[i] > k)tmp[++cur] = sa[i] - k;
            }
            cnt.assign(n + 1,0);
            for(int i = 1;i <= n;i++)cnt[rk[i]]++;
            for(int i = 1;i <= n;i++)cnt[i] += cnt[i - 1];
            for(int i = n;i >= 1;i--)sa[cnt[rk[tmp[i]]]--] = tmp[i];
            swap(rk, tmp);
            rk[sa[1]] = 1;
            for (int i = 2; i <= n;i++){
                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k >= n + 1 || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);
            }
            k <<= 1;
        }
    }
};
```

## <div id = "2"><center>数据结构</center><div>  

### <div id = "2.1">ST表<div>
**1. RMQ**
```C++
template<class T = int,class Cmp = std::less<T>>
struct RMQ{
    const Cmp cmp = Cmp();
    int n,lg;
    vector<vector<T>> st;
    RMQ(){}
    RMQ(vector<T> &v){
        init(v);
    }
    void init(vector<T> &v){
        n = (int)v.size() - 1;
        lg = __lg(n) + 1;
        st.assign(lg,vector<T>(n + 1));
        for(int i = 1;i <= n;i++)st[0][i] = v[i];
        for(int i = 1;i < lg;i++){
            for(int j = 1;j <= n;j++){
                st[i][j] = min(st[i - 1][j],st[i - 1][min(j + (1 << i - 1),n)],cmp);
            }
        }
    }
    T operator()(int l,int r){
        int t = __lg(r - l + 1);
        return min(st[t][l],st[t][r - (1 << t) + 1],cmp);
    }
};
```
**2. ST表 (区间gcd)**
```C++
template<class T,class Cmp>
struct ST{
    const Cmp cmp = Cmp();
    int n,lg;
    vector<vector<T>> st;
    ST(){}
    ST(vector<T> &v){
        init(v);
    }
    void init(vector<T> &v){
        n = (int)v.size() - 1;
        lg = __lg(n) + 1;
        st.assign(lg,vector<T>(n + 1));
        for(int i = 1;i <= n;i++)st[0][i] = v[i];
        for(int i = 1;i < lg;i++){
            for(int j = 1;j <= n;j++){
                st[i][j] = cmp(st[i - 1][j],st[i - 1][min(j + (1 << i - 1),n)]);
            }
        }
    }
    T operator()(int l,int r){
        int t = __lg(r - l + 1);
        return cmp(st[t][l],st[t][r - (1 << t) + 1]);
    }
};

template<class T>
struct Cmp{
    T operator()(const T& x,const T& y)const{return __gcd(x,y);}
};
```

### <div id = "2.2">并查集<div>
- 维护集合大小的并查集
```C++
struct DSU{
	vector<int> p,sz;
	DSU(int n):p(n + 1),sz(n + 1,1){for(int i = 1;i <= n;i++)p[i] = i;}
	int find(int x){return (p[x] == x) ? x : p[x] = find(p[x]);}
	bool same(int x,int y){return find(x) == find(y);}
	bool merge(int x,int y){
		x = find(x),y = find(y);
		if(x == y)return false;
		sz[x] += sz[y];
		p[y] = x;
		return true;
	}
	int size(int x){return sz[find(x)];}
};
```
### <div id = "2.3">树状数组<div>
- 单点修改，查询区间和
```C++  
template<class T>
struct BIT{
    int n;
    vector<T> tr;
    BIT(int n = 0) : n(n),tr(n + 1) {}
	void resize(int m){n = m,tr.resize(m + 1);}
    inline int lowbit(int x){return x & -x;}
    void modify(int x,T y){for(;x <= n;x += lowbit(x))tr[x] +=y;}
    T query(int x){
        T res = 0;
        for(;x > 0;x -= lowbit(x))res += tr[x];
        return res;
    }
    T query(int l,int r){
        return query(r) - query(l - 1);
    }
};
```
- 单点修改，维护二维前缀和
```C++
struct BIT{
    int N,M;
    vector<vector<LL>> tr;
    BIT(int n = 0,int m = 0):N(n),M(m){tr = vector<vector<LL>>(n + 1,vector<LL>(m + 1));}
    inline int lowbit(int x){return x & -x;}
    void resize(int n,int m){
        N = n,M = m;
        tr.resize(n + 1);
        for(int i = 0;i <= n;i++){
            tr[i].resize(m + 1);
        }
    }
    void modifly(int x,int y,int z){
        for(int i = x;i <= N;i += lowbit(i)){
            for(int j = y;j <= M;j += lowbit(j)){
                tr[i][j] += z;
            }
        }
    }
    LL query(int x,int y){
        LL res = 0;
        for(int i = x;i > 0;i -= lowbit(i)){
            for(int j = y;j > 0;j -= lowbit(j)){
                res += tr[i][j];
            }
        }
        return res;
    }
    LL query(int x1,int y1,int x2,int y2){
        return query(x2,y2) - query(x2,y1 - 1) - query(x1 - 1,y2) + query(x1 - 1,y1 - 1);
    }
};
```
- 二阶前缀和
记 $d$ 为一阶差分序列，$d'$ 为二阶差分序列。
$$
\begin{align*}
a_k &= \sum_{i = 1}^{k}d_i \\
&= \sum_{i = 1}^{k}\sum_{j = 1}^{i}d'_j \\
&= \sum_{j = 1}^{k}(k - j + 1) \cdot d'_j \\
&= (k + 1) \cdot \sum_{j = 1}^{k}d'_j + \sum_{j = 1}^{k}j \cdot d'_j
\end{align*}
$$
此时只需维护 $d'_i$ 的前缀和和 $i \times d'_i$ 的前缀和
### <div id = "2.4">线段树<div>
**1. 线段树 (单点修改，区间查询)**
```C++
template<class Info>
struct SegmentTree{
    int n;
    vector<Info> tr;
    SegmentTree():n(0){}
    SegmentTree(int _n,Info _v = Info()){init(_n,_v);}
    template<class T>
    SegmentTree(vector<T> _v){init(_v);}

    void init(int _n,Info _v = Info()){init(vector(_n + 1,_v));}
    template<class T>
    void init(vector<T> _v){
        n = (int)_v.size() - 1;
        tr.resize(n << 2,Info());
        auto build = [&](auto self,int rt,int l,int r)->void{
            if(l == r){
                tr[rt] = _v[l];
                return;
            }
            int mid = (l + r) >> 1;
            self(self,rt << 1,l,mid);
            self(self,rt << 1 | 1,mid + 1,r);
            push_up(rt);
        };
        build(build,1,1,n);
    }
    void push_up(int rt){
        tr[rt] = tr[rt << 1] + tr[rt << 1 | 1];
    }
    void modify(int rt,int l,int r,int p,Info v){
        if(l == r){
            tr[rt] = v;
            return;
        }
        int mid = (l + r) >> 1;
        if(p <= mid)modify(rt << 1,l,mid,p,v);
        else modify(rt << 1 | 1,mid + 1,r,p,v);
        push_up(rt);
    }
    void modify(int p,Info v){modify(1,1,n,p,v);}
    Info query(int rt,int l,int r,int x,int y){
        if(x <= l && r <= y){
            return tr[rt];
        }
        int mid = (l + r) >> 1;
        if(x <= mid && y > mid)return query(rt << 1,l,mid,x,y) + query(rt << 1 | 1,mid + 1,r,x,y);
        else if(x <= mid)return query(rt << 1,l,mid,x,y);
        else return query(rt << 1 | 1,mid + 1,r,x,y);
    }
    Info query(int l,int r){return query(1,1,n,l,r);}
};

struct Info{

    Info() {}
};
Info operator+(Info a,Info b){
    Info c;

    return c;
}
```

**2. 懒标记线段树 (区间修改，区间查询)**
```C++
template<class Info,class Tag>
struct LazySegmentTree{
    int n;
    vector<Info> tr;
    vector<Tag> tag;
    LazySegmentTree(int n) : n(n),tr(n << 2),tag(n << 2) {
        init(vector<Info>(n + 1));
    }
    LazySegmentTree(const vector<Info> &a) : n(a.size() - 1),tr(n << 2),tag(n << 2) {
        init(a);
    }
    void init(const vector<Info> &a){
        auto build = [&](auto self,int rt,int l,int r)->void{
            if(l == r){
                tr[rt] = a[l];
                return;
            }
            int mid = (l + r) >> 1;
            self(self,rt << 1,l,mid);
            self(self,rt << 1 | 1,mid + 1,r);
            push_up(rt);
        };
        build(build,1,1,n);
    }
    void push_up(int rt){
        tr[rt] = tr[rt << 1] + tr[rt << 1 | 1];
    }
    void apply(int rt,int l,int r,const Tag& v){
        tr[rt].apply(l,r,v);
        tag[rt].apply(v);
    }
    void push_down(int rt,int l,int r){
        int mid = (l + r) >> 1;
        apply(rt << 1,l,mid,tag[rt]);
        apply(rt << 1 | 1,mid + 1,r,tag[rt]);
        tag[rt] = Tag();
    }
    void modify(int rt,int l,int r,int x,int y,const Tag& v){
        if(x <= l && r <= y){
            apply(rt,l,r,v);
            return;
        }
        push_down(rt,l,r);
        int mid = (l + r) >> 1;
        if(x <= mid)modify(rt << 1,l,mid,x,y,v);
        if(y > mid)modify(rt << 1 | 1,mid + 1,r,x,y,v);
        push_up(rt);
    }
    void modify(int x,int y,const Tag& v){modify(1,1,n,x,y,v);}
    Info query(int rt,int l,int r,int x,int y){
        if(x <= l && r <= y){
            return tr[rt];
        }
        push_down(rt,l,r);
        int mid = (l + r) >> 1;
        if(x <= mid && y > mid)return query(rt << 1,l,mid,x,y) + query(rt << 1 | 1,mid + 1,r,x,y);
        else if(x <= mid)return query(rt << 1,l,mid,x,y);
        else return query(rt << 1 | 1,mid + 1,r,x,y);
    }
    Info query(int x,int y){return query(1,1,n,x,y);}
};

struct Tag{

	Tag() {}
	void apply(Tag v){

	}	 
};

struct Info{
    
    Info() {}
    void apply(int l,int r,Tag v){

	}
};

Info operator+(Info a,Info b){
    Info c;

    return c;
}
```

**3. 扫描线线段树**
```C++
struct Line{
    LL x1,x2,y;
    int teg;
    bool operator<(const Line &a)const{return y < a.y;}
};
struct Node{
    int l,r;
    LL cnt,len;
};
struct Seg{
    int n;
    vector<Node> tr;
    vector<LL> v;
    void insert(LL x){v.push_back(x);}
    int init(){
        sort(v.begin(),v.end());
        v.erase(unique(v.begin(),v.end()),v.end());
        n = v.size() - 1;
        tr = vector<Node>(n << 3);
        build(1,1,n);
        return v.size();
    }
    int find(LL x){return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;}
    void build(int rt,int l,int r){
        if(l == r){
            tr[rt] = {l,r,0,0};
            return;
        }
        int mid = (l + r) >> 1;
        build(rt << 1,l,mid);
        build(rt << 1 | 1,mid + 1,r);
        tr[rt] = {l,r,0,0};
    }
    void push_up(int rt){
        if(tr[rt].cnt)tr[rt].len = v[tr[rt].r] - v[tr[rt].l - 1];
        else tr[rt].len = tr[rt << 1].len + tr[rt << 1 | 1].len; 
    }
    void modifly(int rt,int l,int r,int teg){
        if(tr[rt].l >= l && tr[rt].r <= r){
            tr[rt].cnt += teg;
            push_up(rt);
            return;
        }
        int mid = (tr[rt].l + tr[rt].r) >> 1;
        if(l <= mid)modifly(rt << 1,l,r,teg);
        if(r > mid)modifly(rt << 1 | 1,l,r,teg);
        push_up(rt);
    }
    LL query(){return tr[1].len;}
};

void solve(){
    int n;
    LL res = 0;
    cin >> n;
    vector<Line> a(2 * n + 1);
    Seg tr;
    for(int i = 1;i <= n;i++){
        int x1,y1,x2,y2;
        cin >> x1 >> y1 >> x2 >> y2;
        a[i] = {x1,x2,y1,1};
        a[n + i] = {x1,x2,y2,-1};
        tr.insert(x1);
        tr.insert(x2);
    }
    n *= 2;
    sort(a.begin() + 1,a.end());
    tr.init();
    for(int i = 1;i < n;i++){
        int l = tr.find(a[i].x1),r = tr.find(a[i].x2);
        tr.modifly(1,l,r - 1,a[i].teg);
        res += (a[i + 1].y - a[i].y) * tr.query();
    }
    cout << res << endl;
}
```
**4.李超线段树**
- 求与$x = k$相交的交点纵坐标最大的线段的编号
```C++
#include<bits/stdc++.h>
using namespace std;

#define endl '\n'
typedef long long LL;
const int p = 39989,N = 100010,mod = 1e9;
const double eps = 1e-9;

struct Line{
    double k,b;
}a[N];
int idx;

struct Node{
    int l,r,id;
}tr[p << 2];

int cmp(double x,double y){
    if(x - y > eps)return 1;
    else if(y - x > eps)return -1;
    else return 0;
}

void add(int x0,int y0,int x1,int y1){
    ++idx;
    if(x0 == x1)a[idx] = {0,(double)max(y0,y1)};
    else{
        a[idx].k = ((double)y0 - y1) / (x0 - x1);
        a[idx].b = (double)y0 - a[idx].k * x0;
    }
}

double f(int id,int x){
    return a[id].k * x + a[id].b;
}

pair<double,int> pmax(pair<double,int> a,pair<double,int> b){
    int flag = cmp(a.first,b.first);
    if(flag == 1)return a;
    else if(flag == -1)return b;
    else return a.second < b.second ? a : b;
}

void build(int rt,int l,int r){
    if(l == r){
        tr[rt] = {l,r,0};
        return;
    }
    int mid = (l + r) >> 1;
    build(rt << 1,l,mid);
    build(rt << 1 | 1,mid + 1,r);
    tr[rt] = {l,r,0};
}

void push_down(int rt,int id){
    int mid = (tr[rt].l + tr[rt].r) >> 1;
    int bmid = cmp(f(id,mid),f(tr[rt].id,mid));
    if(bmid == 1 || (bmid == 0 && id < tr[rt].id))swap(id,tr[rt].id);
    int bl = cmp(f(id,tr[rt].l),f(tr[rt].id,tr[rt].l)),br = cmp(f(id,tr[rt].r),f(tr[rt].id,tr[rt].r));
    if(bl == 1 || (bl == 0 && id < tr[rt].id))push_down(rt << 1,id);
    if(br == 1 || (br == 0 && id < tr[rt].id))push_down(rt << 1 | 1,id);
}

void modifly(int rt,int l,int r,int id){
    if(tr[rt].l >= l && tr[rt].r <= r){
        push_down(rt,id);
        return;
    }
    int mid = (tr[rt].l + tr[rt].r) >> 1;
    if(l <= mid)modifly(rt << 1,l,r,id);
    if(r > mid)modifly(rt << 1 | 1,l,r,id);
}

pair<double,int> query(int rt,int x){
    if(tr[rt].l == tr[rt].r){
        return {f(tr[rt].id,x),tr[rt].id};
    }
    pair<double,int> res = {f(tr[rt].id,x),tr[rt].id};
    int mid = (tr[rt].l + tr[rt].r) >> 1;
    if(x <= mid)res = pmax(res,query(rt << 1,x));
    else res = pmax(res,query(rt << 1 | 1,x));
    return res;
}

void solve() {
    int n,lastans = 0;
    cin >> n;
    build(1,1,p);
    for(int i = 1;i <= n;i++){
        int op;
        cin >> op;
        if(op == 1){
            int x0,y0,x1,y1;
            cin >> x0 >> y0 >> x1 >> y1;
            x0 = (x0 + lastans - 1) % p + 1;
            x1 = (x1 + lastans - 1) % p + 1;
            y0 = (y0 + lastans - 1) % mod + 1;
            y1 = (y1 + lastans - 1) % mod + 1;
            if(x0 > x1){
                swap(x0,x1);
                swap(y0,y1);
            }
            add(x0,y0,x1,y1);
            modifly(1,x0,x1,idx);
        }else{
            int x;
            cin >> x;
            x = (x + lastans - 1) % p + 1;
            lastans = query(1,x).second;
            cout << lastans << endl;
        }
    }

}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL),cout.tie(NULL);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```
### <div id = "2.5">可持久化数据结构<div>
**1. 可持久化线段树**
- 维护区间第$k$小
```C++
struct Seg{
    struct Node{
        int ls,rs,cnt;
    };
    int n,m;
    vector<int> root;
    vector<Node> tr;
	Seg(int n,int m) : n(n),m(m),root(n + 1),tr(1) {}
	int newNode(){
		tr.push_back({});
		return tr.size() - 1;
	}
	void push_up(int rt){
		tr[rt].cnt = tr[tr[rt].ls].cnt + tr[tr[rt].rs].cnt;
	}
	int insert(int x,int y,int l,int r,int v){
		y = newNode();
		if(l == r){
			tr[y].cnt = tr[x].cnt + 1;
			return y;
		}
		tr[y] = tr[x];
		int mid = (l + r) >> 1;
		if(v <= mid)tr[y].ls = insert(tr[x].ls,tr[y].ls,l,mid,v);
		else tr[y].rs = insert(tr[x].rs,tr[y].rs,mid + 1,r,v);
		push_up(y);
		return y;
	};
    void insert(int x,int y,int v){
		root[y] = insert(root[x],root[y],1,m,v);
	}
	int query(int x,int y,int L,int R,int l,int r){
		if(l <= L && R <= r){
			return tr[y].cnt - tr[x].cnt;
		}
		int mid = (L + R) >> 1;
		int res = 0;
		if(l <= mid)res += query(tr[x].ls,tr[y].ls,L,mid,l,r);
		if(r > mid)res += query(tr[x].rs,tr[y].rs,mid + 1,R,l,r);
		return res;
	}
	int query(int x,int y,int l,int r){
		return query(root[x - 1],root[y],1,m,l,r);
	}
	int kth(int x,int y,int l,int r,int k){
		if(l == r){
			return l;
		}
		int mid = (l + r) >> 1;
		int cnt = tr[tr[y].ls].cnt - tr[tr[x].ls].cnt;
		if(k <= cnt)return kth(tr[x].ls,tr[y].ls,l,mid,k);
		else return kth(tr[x].rs,tr[y].rs,mid + 1,r,k - cnt);
	}
	int kth(int x,int y,int k){
		return kth(root[x - 1],root[y],1,m,k);
	}
};
```
### <div id = "2.6">平衡树<div>
**1. splay**
```C++
struct Tree{
    struct Node{
        int s[2];
        int fa,siz,val,cnt;
        void init(int v,int p){val = v,fa = p,siz = cnt = 1;}
    };
    int root,idx;
    vector<Node> tr;
    Tree(){
        root = idx = 0;
        tr = vector<Node>(1);
        insert(1e9),insert(-1e9);
    }
    void push_up(int x){tr[x].siz = tr[tr[x].s[0]].siz + tr[tr[x].s[1]].siz + tr[x].cnt;}
    void rotate(int x){
        int y = tr[x].fa,z = tr[y].fa;
        int k = (tr[y].s[1] == x);
        tr[z].s[tr[z].s[1] == y] = x;
        tr[x].fa = z;
        tr[y].s[k] = tr[x].s[k ^ 1];
        tr[tr[x].s[k ^ 1]].fa = y;
        tr[x].s[k ^ 1] = y;
        tr[y].fa = x;
        push_up(y),push_up(x);
    }
    void splay(int x,int k){
        while(tr[x].fa != k){
            int y = tr[x].fa,z = tr[y].fa;
            if(z != k)(tr[y].s[0] == x) ^ (tr[z].s[0] == y) ? rotate(x) : rotate(y);
            rotate(x);
        }
        if(!k)root = x;
    }
    void insert(int v){
        int x = root,p = 0;
        while(x && tr[x].val != v)p = x,x = tr[x].s[v > tr[x].val];
        if(x)tr[x].cnt++;
        else{
            tr.push_back({});
            x = ++idx;
            tr[p].s[v > tr[p].val] = x;
            tr[x].init(v,p);
        }
        splay(x,0);
    }
    void find(int v){
        int x = root;
        while(tr[x].s[v > tr[x].val] && tr[x].val != v)x = tr[x].s[v > tr[x].val];
        splay(x,0);
    }
    int Pre(int v){
        find(v);
        int x = root;
        if(tr[x].val < v)return x;
        x= tr[x].s[0];
        while(tr[x].s[1])x = tr[x].s[1];
        splay(x,0);
        return x;
    }
    int pre(int v){
        return tr[Pre(v)].val;
    }
    int Suc(int v){
        find(v);
        int x = root;
        if(tr[x].val > v)return x;
        x = tr[x].s[1];
        while(tr[x].s[0])x = tr[x].s[0];
        splay(x,0);
        return x;
    }
    int suc(int v){
        return tr[Suc(v)].val;
    }
    void del(int v){
        int pre = Pre(v);
        int suc = Suc(v);
        splay(pre,0),splay(suc,pre);
        int del = tr[suc].s[0];
        if(tr[del].cnt > 1){
            tr[del].cnt--;
            splay(del,0);
        }else{
            tr[suc].s[0] = 0;
            splay(suc,0);
        }
    }
    int rank(int v){
        insert(v);
        int res = tr[tr[root].s[0]].siz;
        del(v);
        return res;
    }
    int kth(int k){
        int x = root;
        k++;
        while(true){
            int y = tr[x].s[0];
            if(tr[y].siz + tr[x].cnt < k){
                k -= tr[y].siz + tr[x].cnt;
                x = tr[x].s[1];
            }else if(tr[y].siz >= k)x = y;
            else break;
        }
        splay(x,0);
        return tr[x].val;
    }
};
```
## <div id = "3"><center>图论</center><div>  
### <div id = "3.1">单源最短路<div>

**1.dijkstra算法**
```C++
void dijkstra(int s){
    vector<bool> st(n + 1);
    priority_queue<pair<LL,int>,vector<pair<LL,int>>,greater<pair<LL,int>>> q;
    dist[s] = 0;
    q.push({dist[s],s});
    while(q.size()){
        int u = q.top().second;
        q.pop();
        if(st[u])continue;
        st[u] = true;
        for(auto [v,w] : edge[u]){
            if(dist[v] > dist[u] + w){
                dist[v] = dist[u] + w;
                q.push({dist[v],v});
            }
        }
    }
}
```
**2.SPFA算法**
- 差分约束
    建立超级源点 $S$，向每个点连一条边权为0的边 $S \xrightarrow{0} u$
    约束 $u_i - v_i \le w_i$ 等价于 $v_i \xrightarrow{c_i} u_i$
    约束 $u_i - v_i = w_i$ 等价于 $u_i - v_i \le w_i \land u_i - v_i \ge w_i$
    跑 $SPFA$，如果存在负环。则无解，否则 $dist_i$ 则为一组解
```C++
auto spfa = [&](int s)->bool{
    vector<bool> st(n + 1);
    vector<int> cnt(n + 1);
    queue<int> q;
    dist[s] = 0;
    q.push(s);
    st[s] = true;
    while(q.size()){
        int u = q.front();
        q.pop();
        st[u] = false;
        for(auto [v,w] : edge[u]){
            if(dist[v] > dist[u] + w){
                dist[v] = dist[u] + w;
                if(!st[v]){
                    st[v] = true;
                    cnt[v]++;
                    q.push(v);
                    if(cnt[v] >= n)return false;
                }
            }
        }
    }
    return true;
};
```


### <div id = "3.2">全源最短路<div>
**1.Johnson算法**
```C++
void solve(){
    int n,m;
    cin >> n >> m;
    vector<vector<pair<int,LL>>> edge(n + 1);
    vector<LL> h(n + 1,1e9),dist(n + 1,1e9);
    for(int i = 1;i <= m;i++){
        int u,v,w;
        cin >> u >> v >> w;
        edge[u].push_back({v,w});
    }
    for(int i = 1;i <= n;i++){
        edge[0].push_back({i,0});
    }
    auto spfa = [&](int s)->bool{
        vector<bool> st(n + 1);
        vector<int> cnt(n + 1);
        queue<int> q;
        h[s] = 0;
        q.push(s);
        st[s] = true;
        while(q.size()){
            int u = q.front();
            q.pop();
            st[u] = false;
            for(auto [v,w] : edge[u]){
                if(h[v] > h[u] + w){
                    h[v] = h[u] + w;
                    if(!st[v]){
                        st[v] = true;
                        cnt[v]++;
                        q.push(v);
                        if(cnt[v] >= n + 1)return false;
                    }
                }
            }
        }
        return true;
    };
    auto dijkstra = [&](int s)->void{
        vector<bool> st(n + 1);
        priority_queue<pair<LL,int>,vector<pair<LL,int>>,greater<pair<LL,int>>> q;
        dist[s] = 0;
        q.push({0,s});
        while(q.size()){
            int u = q.top().second;
            q.pop();
            if(st[u])continue;
            st[u] = true;
            for(auto [v,w] : edge[u]){
                if(dist[v] > dist[u] + w){
                    dist[v] = dist[u] + w;
                    q.push({dist[v],v});
                }
            }
        }
    };
    if(!spfa(0))cout << -1 << endl;
    else{
        LL res = 0;
        for(int u = 1;u <= n;u++){
            for(auto &[v,w] : edge[u]){
                w += h[u] - h[v];
            }
        }
        for(int i = 1;i <= n;i++){
            res = 0;
            dist.assign(n + 1,1e9);
            dijkstra(i);
            for(int j = 1;j <= n;j++){
                if(dist[j] == 1e9)res += j * dist[j];
                else res += j * (dist[j] + h[j] - h[i]);
            }
            cout << res << endl;
        }
    }
}
```

### <div id = "3.3">二分图<div>

**1.染色法判二分图**
二分图不存在长度为奇数的环，染色法可以判断是否存在奇环。
```C++
auto dfs = [&](auto self,int u,int c)->bool{
    col[u] = c;
    bool flag = true;
    for(auto v : edge[u]){
        if(col[v] == -1)flag &= self(self,v,c ^ 1);
        else if(col[v] == col[u])return false;
    }
    return flag;
};
```

**2.二分图匹配(匈牙利算法)**

$时间复杂度O(nm)$

```C++
struct Hungarian{
    int n,m,_flag,res;
    vector<vector<int>> edge;
    vector<int> match;
    vector<int> st;
    Hungarian(int _n = 0,int _m = 0){
        n = _n;
        m = _m;
        _flag = 0;
        res = 0;
        edge.resize(n + 1,vector<int>());
        match.resize(m + 1,0);
        st.resize(m + 1,0);
    }

    void add_edge(int u,int v){
        edge[u].push_back(v);
    }

    bool find(int u,int flag){
        for(auto v : edge[u]){
            if(st[v] == flag)continue;
            st[v] = flag;
            if(!match[v] || find(match[v],flag)){
                match[v] = u;
                return true;
            }
        }
        return false;
    }

    int work(){
        match.assign(m + 1,0);
        st.assign(m + 1,0);
        _flag = 0;
        res = 0;
        for(int i = 1;i <= n;i++){
            if(find(i,++_flag))res++;
        }
        return res;
    }

};
```

**3.二分图匹配(dinic算法)**

  转化为最大流模型
  建立虚拟源点S向左部点连流量为1的边，右部点向虚拟汇点T连流量为1的边，此时最大流即为最大匹配。

$时间复杂度O(\sqrt{n}m)$

**4.二分图最大权完美匹配(KM算法)**

$时间复杂度O(n^3)$
```C++
template<typename T = long long>
struct KM{
    int n,org_n,org_m;
    vector<int> matchx,matchy;
    vector<int> pre;
    vector<bool> visx,visy;
    vector<T> lx,ly;
    vector<vector<T>> edge;
    vector<T> slack;
    T inf,res;
    queue<int> q;
    
    KM(int _n,int _m){
        org_n = _n,org_m = _m;
        n = max(_n,_m);
        inf = numeric_limits<T>::max();
        res = 0;
        //完美匹配初始化为-inf(太小会爆),否则初始化为0
        edge = vector<vector<T>>(n + 1,vector<T>(n + 1));
        matchx = vector<int>(n + 1);
        matchy = vector<int>(n + 1);
        pre = vector<int>(n + 1);
        visx = vector<bool>(n + 1);
        visy = vector<bool>(n + 1);
        lx = vector<T>(n + 1,-inf);
        ly = vector<T>(n + 1);
        slack = vector<T>(n + 1);
    }

    void add_edge(int u,int v,T w){
        edge[u][v] = max(edge[u][v],w);
    }

    bool check(int v){
        visy[v] = true;
        if(matchy[v] != 0){
            q.push(matchy[v]);
            visx[matchy[v]] = true;
            return false;
        }
        while(v){
            matchy[v] = pre[v];
            swap(v,matchx[pre[v]]);
        }
        return true;
    }

    void bfs(int s){
        while(!q.empty())q.pop();
        q.push(s);
        visx[s] = true;
        while(true){
            while(!q.empty()){
                int u = q.front();
                q.pop();
                for(int v = 1;v <= n;v++){
                    if(!visy[v]){
                        T delta = lx[u] + ly[v] - edge[u][v];
                        if(slack[v] >= delta){
                            pre[v] = u;
                            if(delta){
                                slack[v] = delta;
                            }else if(check(v)){
                                return;
                            }
                        }

                    }
                }
            }

            T a = inf;
            for(int i = 1;i <= n;i++){
                if(!visy[i])a = min(a,slack[i]);
            }
            for(int i = 1;i <= n;i++){
                if(visx[i])lx[i] -= a;
                if(visy[i])ly[i] += a;
                else slack[i] -= a;
            }
            for(int i = 1;i <= n;i++){
                if(!visy[i] && slack[i] == 0 && check(i)){
                    return;
                }
            }

        }

    }

    T work(){
        for(int i = 1;i <= n;i++){
            for(int j = 1;j <= n;j++){
                lx[i] = max(lx[i],edge[i][j]);
            }
        }

        for(int i = 1;i <= n;i++){
            fill(slack.begin() + 1,slack.end(),inf);
            fill(visx.begin() + 1,visx.end(),false);
            fill(visy.begin() + 1,visy.end(),false);
            bfs(i);
        }
        res = 0;
        for(int i = 1;i <= n;i++){
            if(edge[i][matchx[i]] > 0)res += edge[i][matchx[i]];
        }
        return res;
    }
};
```

**5.二分图最小点覆盖、最大团、最大独立集**
- 最小点覆盖：选最少的点，满足每一条边至少有一个端点被选择
- 二分图中，最小点覆盖 $=$ 最大匹配
- 最大独立集：选最多的点，满足两两之间没有边相连。
- 最大独立集 $=$ $|V|$ $-$ 最小点覆盖。
- 最大团：选择最多的点，满足任意两点有一条边相连。
- 最大团 $=$ 补图的最大独立集


### <div id = "3.4">图的连通性相关<div>
**1. tarjan缩点**
- 时间戳 $dfn[u]$：$u$第一次被访问的顺序
- 追溯值 $low[u]$：从$u$出发所能访问到的最早的时间戳
- $tarjan$ 缩点后给出的点是逆拓扑序

$时间复杂度O(n)$

```C++
struct SCC{
    vector<vector<int>> edge;
    vector<int> stk;
    vector<bool> instk;
    vector<int> dfn,low,scc;
    int n,tot,cnt;

    SCC(int n = 0) : n(n) {
        init(n);
    }
    void init(int n){
        edge.resize(n + 1);
        stk.clear();
        instk.resize(n + 1);
        dfn.resize(n + 1);
        low.resize(n + 1);
        scc.resize(n + 1);
        tot = cnt = 0;
    }

    void addEdge(int u,int v){
        edge[u].push_back(v);
    }
    void tarjan(int u){
        dfn[u] = low[u] = ++tot;
        stk.push_back(u);
        instk[u] = true; 
        for(auto v : edge[u]){
            if(!dfn[v]){
                tarjan(v);
                low[u] = min(low[u],low[v]);
            }else if(instk[v]){
                low[u] = min(low[u],dfn[v]);
            }
        }
        if(dfn[u] == low[u]){
            int x;
            cnt++;
            do{
                x = stk.back();
                stk.pop_back();
                instk[x] = false;
                scc[x] = cnt; 
            }while(x != u);
        }
    }
    void work(){
        for(int i = 1;i <= n;i++){
            if(!dfn[i])tarjan(i);
        }
    }
    int operator[](const int i) const {
        return scc[i];
    }
};
```
**2. tarjan割点**
- 割点判定法则
    如果$u$不是根节点,当搜索树上存在$u$的一个子节点$v$,满足$low[v] \geq dfn[u]$,那么$u$就是割点。
    如果$u$是根节点,当搜索树上存在至少两个子节点$v_1,v_2$，满足上述条件,那么$x$就是割点。

$时间复杂度O(n)$

```C++
int idx = 0,rt;
vector<int> dfn(n + 1),low(n + 1);
vector<int> cut(n + 1);
auto tarjan = [&](auto self,int u)->void{
    int cnt = 0;
    dfn[u] = low[u] = ++idx;
    for(auto v : edge[u]){
        if(!dfn[v]){
            self(self,v);
            low[u] = min(low[u],low[v]);
            if(low[v] >= dfn[u]){
                cnt++;
                if(u != rt || cnt > 1)cut[u] = 1;
            }
         }else{
            low[u] = min(low[u],dfn[v]);
        }
    }
};
```

**3. tarjan割边与边双连通分量**
- 割边判定法则
当搜索树上存在 $x$ 的一个子节点 $y$，满足$low[y] > dfn[x]$，则 $(x,y)$ 这条边就是割边

```C++
struct EDCC{
    vector<pair<int,int>> adj;
    vector<vector<int>> edge;
    vector<int> stk;
    vector<int> dfn,low,dcc;
    vector<bool> bridge;
    int n,tot,cnt;

    EDCC(int n = 0) : n(n) {
        init(n);
    }
    void init(int n){
        edge.resize(n + 1);
        stk.clear();
        dfn.resize(n + 1);
        low.resize(n + 1);
        dcc.resize(n + 1);
        tot = cnt = 0;
    }

    void addEdge(int u,int v){
        adj.push_back({u,v});
        edge[u].push_back(adj.size() - 1);
        bridge.push_back(false);
        adj.push_back({v,u});
        edge[v].push_back(adj.size() - 1);
        bridge.push_back(false);
    }
    void tarjan(int u,int p){
        dfn[u] = low[u] = ++tot;
        stk.push_back(u);
        for(auto i : edge[u]){
            int v = adj[i].second;
            if(!dfn[v]){
                tarjan(v,i);
                low[u] = min(low[u],low[v]);
                if(low[v] > dfn[u]){
                    bridge[i] = bridge[i ^ 1] = true;
                }
            }else if(i != (p ^ 1)){
                low[u] = min(low[u],dfn[v]);
            }
        }
        if(dfn[u] == low[u]){
            ++cnt;
            int v;
            do{
                v = stk.back();
                stk.pop_back();
                dcc[v] = cnt;
            }while(v != u);
        }
    }
    void work(){
        for(int i = 1;i <= n;i++){
            if(!dfn[i])tarjan(i,-1);
        }
    }
    int operator[](const int i) const {
        return dcc[i];
    }
};
```

### <div id = "3.5">网络流<div>
**1.最大流 (EK算法)**

时间复杂度$O(nm^2)$

```C++
template<class T>
struct MaxFlow{
    struct Edge{
        int v;
        T cap;
    };
    int n;
    vector<Edge> edge;
    vector<vector<int>> h;
    vector<T> mf;
    vector<int> pre;
    MaxFlow(){}
    MaxFlow(int _n){init(_n);}
    void init(int _n){
        n = _n;
        edge.clear();
        h.assign(n + 1,{});
        pre.resize(n + 1);
        mf.resize(n + 1);
    }
    void addEdge(int u,int v,T c){
        h[u].push_back(edge.size());
        edge.push_back({v,c});
        h[v].push_back(edge.size());
        edge.push_back({u,0});
    }
    bool bfs(int s,int t){
        mf.assign(n + 1,T());
        queue<int> q;
        q.push(s);
        mf[s] = std::numeric_limits<T>::max();
        while(q.size()){
            int u = q.front();
            q.pop();
            for(auto i : h[u]){
                auto [v,c] = edge[i];
                if(mf[v] == 0 && c){
                    mf[v] = min(mf[u],c);
                    pre[v] = i;
                    q.push(v);
                    if(v == t)return true;
                }
            }
        }
        return false;
    }
    T flow(int s,int t){
        T flow = {};
        while(bfs(s,t)){
            int v = t;
            while(v != s){
                int i = pre[v];
                edge[i].cap -= mf[t];
                edge[i ^ 1].cap += mf[t];
                v = edge[i ^ 1].v;
            }
            flow += mf[t];
        }
        return flow;
    }
};
```
**2.最大流 (dinic算法)**

时间复杂度$O(n^2m)$

```C++
template<class T>
struct MaxFlow{
    struct Edge{
        int v;
        T cap;
    };
    int n;
    vector<Edge> edge;
    vector<vector<int>> h;
    vector<int> cur,dep;
    MaxFlow(){}
    MaxFlow(int _n){init(_n);}
    void init(int _n){
        n = _n;
        edge.clear();
        h.assign(n + 1,{});
        cur.resize(n + 1);
        dep.resize(n + 1);
    }
    void addEdge(int u,int v,T c){
        h[u].push_back(edge.size());
        edge.push_back({v,c});
        h[v].push_back(edge.size());
        edge.push_back({u,0});
    }
    bool bfs(int s,int t){
        dep.assign(n + 1,0);
        queue<int> q;
        q.push(s);
        dep[s] = 1;
        while(q.size()){
            int u = q.front();
            q.pop();
            for(auto i : h[u]){
                auto [v,c] = edge[i];
                if(dep[v] == 0 && c){
                    dep[v] = dep[u] + 1;
                    q.push(v);
                    if(v == t)return true;
                }
            }
        }
        return false;
    }
    T dfs(int u,int t,T mf){
        if(u == t)return mf;
        T sum = 0;
        for(int &i = cur[u];i < (int)(h[u].size());i++){
            int j = h[u][i];
            auto [v,c] = edge[j];
            if(dep[v] == dep[u] + 1 && c > 0){
                T f = dfs(v,t,min(mf,c));
                edge[j].cap -= f;
                edge[j ^ 1].cap += f;
                sum += f;
                mf -= f;
                if(mf == 0)break;
            }
        }
        if(sum == 0)dep[u] = 0;
        return sum;
    }
    T flow(int s,int t){
        T res = 0;
        while(bfs(s,t)){
            cur.assign(n + 1,0);
            res += dfs(s,t,std::numeric_limits<T>::max());
        }
        return res;
    }
};
```

**3. 最小割**

- 最小割划分方案(基于dinic)
从源点开始，走残量网中流量大于 $0$ 的边，找到 $S$ 集合内所有点
```C++
vector<bool> minCut() {
    vector<bool> c(n + 1);
    for (int i = 1;i <= n; i++) {
        c[i] = (h[i] != 0);
    }
    return c;
}
```
- 最小化割边数量
在最小割的前提下最小化割边数量，那么先求出最小割，把没有满流的边容量改成 $\infty$，满流的边容量改成 $1$，重新跑一遍最小割就可求出最小割边数量
也可以将流量更改为 $(m + 1) * f_i + 1$，由于割边数量不可能超过 $m$，所以最小割为 $MaxFlow / (m + 1)$，最小割边树 $MaxFlow \% (m + 1)$
如果没有最小割的前提，直接把所有边的容量设成 $1$，求一遍最小割即可的最小割边数量

**4. 费用流**

时间复杂度$O(nmf)$

- 基于SPFA
可自定义最小费用流或最大费用流
```C++
template<class Cmp = greater<LL>,LL initv = numeric_limits<LL>::max()>
struct MCFGraph {
    struct Node {
        int v,c,f;
        Node(int v, int c, int f) : v(v),c(c),f(f) {}
    };
    int n;
    vector<Node> adj;
    vector<vector<int>> edge;
    vector<LL> dist;
    vector<int> pre,st,cnt;
    MCFGraph(int n) : n(n),edge(n + 1) {}
    void addEdge(int u,int v,int c,int f){
        edge[u].push_back(adj.size());
        adj.push_back({v,c,f});
        edge[v].push_back(adj.size());
        adj.push_back({u,0,-f});
    }
    bool spfa(int s,int t){
        dist.assign(n + 1,initv);
        pre.assign(n + 1,-1);
        st.assign(n + 1,0);
        cnt.assign(n + 1,0);
        queue<int> q;
        dist[s] = 0;
        q.push(s);
        st[s] = true;
        auto cmp = Cmp();
        while(q.size()){
            int u = q.front();
            q.pop();
            st[u] = false;
            for(int i : edge[u]){
				auto [v,c,f] = adj[i];
                if (c > 0 && cmp(dist[v],dist[u] + f)){
                    dist[v] = dist[u] + f;
                    pre[v] = i;
                    if(!st[v]){
                        st[v] = true;
                        cnt[v]++;
                        q.push(v);
                    }
                }
            }
        }
        return dist[t] != initv;
    };
    pair<int, LL> flow(int s,int t) {
        int flow = 0;
        LL cost = 0;
        while(spfa(s,t)){
            int aug = numeric_limits<int>::max();
            for(int i = t;i != s;i = adj[pre[i] ^ 1].v){
				aug = min(aug,adj[pre[i]].c);
			}
			for(int i = t;i != s;i = adj[pre[i] ^ 1].v){
                adj[pre[i]].c -= aug;
                adj[pre[i] ^ 1].c += aug;
            }
            flow += aug;
            cost += LL(aug) * dist[t];
        }
        return {flow, cost};
    }
};
```

- 基于Primal-Dual 原始对偶算法

```C++
struct MCFGraph {
    struct Node {
        int v,c,f;
        Node(int v, int c, int f) : v(v),c(c),f(f) {}
    };
    int n;
    vector<Node> adj;
    vector<vector<int>> edge;
    vector<LL> h,dist;
    vector<int> pre;
    MCFGraph(int n) : n(n),edge(n + 1) {}
    void addEdge(int u,int v,int c,int f) {
        edge[u].push_back(adj.size());
        adj.push_back({v,c,f});
        edge[v].push_back(adj.size());
        adj.push_back({u,0,-f});
    }
    bool dijkstra(int s,int t) {
		// 初始无负费用边
        dist.assign(n + 1,numeric_limits<LL>::max());
        pre.assign(n + 1,-1);
        priority_queue<pair<LL,int>,vector<pair<LL,int>>,greater<pair<LL,int>>> q;
        dist[s] = 0;
        q.push({0,s});
        while(q.size()) {
            auto [d,u] = q.top();
			q.pop();
            if(dist[u] < d)continue;
            for(int i : edge[u]){
				auto [v,c,f] = adj[i];
                if (c > 0 && dist[v] > d + h[u] - h[v] + f){
                    dist[v] = d + h[u] - h[v] + f;
                    pre[v] = i;
                    q.push({dist[v],v});
                }
            }
        }
        return dist[t] != numeric_limits<LL>::max();
    }
    pair<int, LL> flow(int s,int t) {
        int flow = 0;
        LL cost = 0;
        h.assign(n + 1, 0);
        while(dijkstra(s, t)){
            for(int i = 1;i <= n;++i)h[i] += dist[i];
            int aug = numeric_limits<int>::max();
            for(int i = t;i != s;i = adj[pre[i] ^ 1].v){
				aug = min(aug,adj[pre[i]].c);
			}
			for(int i = t;i != s;i = adj[pre[i] ^ 1].v){
                adj[pre[i]].c -= aug;
                adj[pre[i] ^ 1].c += aug;
            }
            flow += aug;
            cost += LL(aug) * h[t];
        }
        return {flow, cost};
    }
};
```

### <div id = "3.6">树链剖分<div>
```C++
struct HLD{
    int n;
    vector<vector<int>> edge;
    vector<int> sz,dep,parent,top,in,out,seq;
    int cur;

    HLD(){}
    HLD(int n){
        init(n);
    }
    void init(int n){
        this->n = n;
        edge.resize(n + 1);
        sz.resize(n + 1);
        dep.resize(n + 1);
        parent.resize(n + 1);
        top.resize(n + 1);
        in.resize(n + 1);
        out.resize(n + 1);
        seq.resize(n + 1);
        cur = 0;
    }
    void addEdge(int u,int v){
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    void work(int root = 1){
        dfs1(root,0);
        dfs2(root,root);
    }
    void dfs1(int u,int p){
        sz[u] = 1;
        dep[u] = dep[p] + 1;
        parent[u] = p;
        if(parent[u]){
            edge[u].erase(find(edge[u].begin(),edge[u].end(),parent[u]));
        }
        for(auto &v : edge[u]){
            dfs1(v,u);
            sz[u] += sz[v];
            if(sz[v] > sz[edge[u][0]]){
                swap(v,edge[u][0]);
            }
        }
    }
    void dfs2(int u,int p){
        in[u] = ++cur;
        seq[cur] = u;
        top[u] = p;
        for(auto v : edge[u]){
            dfs2(v,v == edge[u][0] ? top[u] : v);
        }
        out[u] = cur;
    }
    int lca(int x,int y){
        while(top[x] != top[y]){
            if(dep[top[x]] > dep[top[y]]){
                x = parent[top[x]];
            }else{
                y = parent[top[y]];
            }
        }
        return dep[x] < dep[y] ? x : y; 
    }
    int dist(int x,int y){
        return dep[x] + dep[y] - 2 * dep[lca(x,y)];
    }
    int jump(int x,int k){
        if(dep[x] <= k)return -1;
        int d = dep[x] - k;
        while(dep[top[x]] > d){
            x = parent[top[x]];
        }
        return seq[in[x] - dep[x] + d];
    }
    pair<int,int> link(int &x,int &y){
        pair<int,int> res;
        if(top[x] != top[y]){
            if(dep[top[x]] > dep[top[y]]){
                res = {in[top[x]],in[x]};
                x = parent[top[x]];
            }else{
                res = {in[top[y]],in[y]};
                y = parent[top[y]];
            }
        }else{
            if(dep[x] <= dep[y]){
                res = {in[x],in[y]};
            }else{
                res = {in[y],in[x]};
            }
            x = 0,y = 0;
        }
        return res;
    }
    pair<int,int> subtree(int x){
        return {in[x],out[x]};
    }
};
```

### <div id = "3.7">斯坦纳树<div>

给定带权无向连通图$G = (V,E)$和包含$k$个点的点集$S$
求出$G$的子图$G' = (V',E')$使得
1. $S \subseteq V'$
2. $G'$为连通图
3. $E'$中的边权和最小

考虑使用状压$dp$求解，定义$dp(i,S)$表示以$i$为根的一棵树，包含点集$S$中所有点的最小边权和。
状态转移：
- 对连通子集进行转移，$dp(i,S) \leftarrow \min(dp(i,S),dp(i,T)+dp(i,S-T))$。
- 在当前的子集连通状态下进行边的松弛操作，$dp(i,S)\leftarrow \min(dp(i,S),dp(j,S) + w(j,i))$，使用$dijkstra$实现。

```C++
void solve(){
    int n,m,k;
    cin >> n >> m >> k;
    vector<vector<pair<int,int>>> edge(n);
    for(int i = 1;i <= m;i++){
        int u,v,w;
        cin >> u >> v >> w;
        u--,v--;
        edge[u].push_back({v,w});
        edge[v].push_back({u,w});
    }
    vector<int> s(k);
    for(int i = 0;i < k;i++){
        cin >> s[i];
        s[i]--;
    }
    vector<vector<int>> dp(n,vector<int>(1 << k,1e9));
    for(int i = 0;i < k;i++){
        dp[s[i]][1 << i] = 0;
    }

    for(int i = 1;i < 1 << k;i++){
        for(int j = (i - 1) & i;j > 0;j = (j - 1) & i){
            for(int u = 0;u < n;u++){
                dp[u][i] = min(dp[u][i],dp[u][j] + dp[u][i ^ j]);
            }
        }

        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;
        vector<bool> st(n);
        for(int u = 0;u < n;u++)q.push({dp[u][i],u});
        while(q.size()){
            auto [_,u] = q.top();
            q.pop();
            if(st[u])continue;
            st[u] = true;
            for(auto [v,w] : edge[u]){
                if(dp[v][i] > dp[u][i] + w){
                    dp[v][i] = dp[u][i] + w;
                    q.push({dp[v][i],v});
                }
            }
        }
    }
    int res = 1e9;
    for(int i = 0;i < n;i++){
        res = min(res,dp[i][(1 << k) - 1]);
    }
    cout << res << endl;
} 
```

### <div id = "3.8">2-SAT<div>
```C++
struct TwoSat{
    int n;
    vector<vector<int>> edge;
    vector<bool> ans;
    TwoSat(int n) : n(n),edge(2 * n + 1),ans(n + 1) {}
    void addEdge(int u,int v){
        edge[u].push_back(v);
    }
    void addClause(int u, int f, int v,int g) {
        edge[u + n * f].push_back(v + n * (g ^ 1));
        edge[v + n * g].push_back(u + n * (f ^ 1));
    }
    bool work(){
        int idx = 0,cnt = 0;
        vector<int> dfn(2 * n + 1),low(2 * n + 1),scc(2 * n + 1);
        vector<bool> instk(2 * n + 1);
        stack<int> stk;
        auto tarjan = [&](auto self,int u)->void{
            dfn[u] = low[u] = ++idx;
            stk.push(u);
            instk[u] = true; 
            for(auto v : edge[u]){
                if(!dfn[v]){
                    self(self,v);
                    low[u] = min(low[u],low[v]);
                }else if(instk[v]){
                    low[u] = min(low[u],dfn[v]);
                }
            }
            if(dfn[u] == low[u]){
                int x;
                cnt++;
                do{
                    x = stk.top();
                    stk.pop();
                    instk[x] = false;
                    scc[x] = cnt;
                }while(x != u);
            }
        };
        for(int i = 1;i <= 2 * n;i++){
            if(!dfn[i])tarjan(tarjan,i);
        }
        for(int i = 1;i <= n;i++){
            if(scc[i] == scc[i + n])return false;
            ans[i] = scc[i] < scc[i + n];
        }
        return true;
    }
    bool operator[](const int i) const {
        return ans[i];
    }
};
```

## <div id = "4"><center>数学</center><div>  

### <div id = '4.1'>取模类<div>
```C++
template<class T>
T qmi(T a,LL k){
    T res = 1;
    while(k){
        if(k & 1)res *= a;
        a *= a;
        k >>= 1;
    }
    return res;
}

struct MInt{
    int v;
    const static int Mod;
    MInt() : v() {}
    MInt(LL _v) : v(norm(_v % Mod)) {}
    static int getMod(){
        return Mod;
    }
    int norm(int x) const {
        if(x < 0){
            x += Mod;
        }else if(x >= Mod){
            x -= Mod;
        }
        return x;
    }
    int val() const {return v;}
    MInt operator-() const {
        MInt res;
        res.v = norm(Mod - v);
        return res;
    }
    MInt inv() const {
        return qmi(*this,Mod - 2);
    }
    MInt &operator*=(MInt rhs) & {
        v = 1LL * v * rhs.v % Mod;
        return *this;
    }
    MInt &operator+=(MInt rhs) & {
        v = norm(v + rhs.v);
        return *this;
    }
    MInt &operator-=(MInt rhs) & {
        v = norm(v - rhs.v);
        return *this;
    }
    MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend MInt operator*(MInt lhs, MInt rhs) {
        return 1LL * lhs.val() * rhs.val();
    }
    friend MInt operator+(MInt lhs, MInt rhs) {
        return lhs.val() + rhs.val();
    }
    friend MInt operator-(MInt lhs, MInt rhs) {
        return lhs.val() - rhs.val();
    }
    friend MInt operator/(MInt lhs, MInt rhs) {
        return 1LL * lhs.val() * rhs.inv().val();
    }
    friend std::istream &operator>>(std::istream &is, MInt &a) {
        LL v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend bool operator<(MInt lhs,MInt rhs) {
        return lhs.val() < rhs.val();
    }
    friend bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
const int MInt::Mod = 998244353;
using Z = MInt;
```

### <div id = "4.2">组合数<div>
```C++
struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _facinv;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _facinv{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _facinv.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _facinv[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _facinv[i - 1] = _facinv[i] * i;
            _inv[i] = _facinv[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z facinv(int m) {
        if (m > n) init(2 * m);
        return _facinv[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * facinv(m) * facinv(n - m);
    }
}comb;
```

### <div id = "4.3">复数类<div>
```C++
struct Complex{
	double x,y;
	Complex(double _x = 0,double _y = 0) : x(_x), y(_y) {}
	Complex operator+(const Complex& a){ return Complex(x + a.x,y + a.y); }
	Complex operator-(const Complex& a){ return Complex(x - a.x,y - a.y); }
	Complex operator*(const Complex& a){ return Complex(x * a.x - y * a.y,x * a.y + y * a.x); }
};
```

### <div id = "4.4">矩阵类<div>
```C++
template<class T>
struct Matrix{
    int n;
    vector<vector<T>> a;
    Matrix(int n) : n(n),a(n,vector<T>(n)) {}

    vector<T>& operator[](int i) {
        return a[i];
    }
    
    const vector<T>& operator[](int i) const {
        return a[i];
    }
    
    Matrix<T>& operator*=(const Matrix<T> &b) {
        Matrix<T> res(n);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                for(int k = 0; k < n; k++){
                    res[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        *this = res;
        return *this;
    }
    
    Matrix<T>& operator+=(const Matrix<T> &b) {
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                a[i][j] += b[i][j];
            }
        }
        return *this;
    }
    
    Matrix<T>& operator-=(const Matrix<T> &b) {
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                a[i][j] -= b[i][j];
            }
        }
        return *this;
    }
    
    friend Matrix<T> operator*(Matrix<T> a, const Matrix<T> &b) {
        return a *= b;
    }
    
    friend Matrix<T> operator+(Matrix<T> a, const Matrix<T> &b) {
        return a += b;
    }
    
    friend Matrix<T> operator-(Matrix<T> a, const Matrix<T> &b) {
        return a -= b;
    }
};
```

### <div id = "4.5">数论<div>
**1. 扩展欧几里得**

- 拓展欧几里得算法
$a*x_0+b*y_0=gcd(a,b)$
$\Rightarrow b\times x+(a\%b)\times y=gcd(a,b)$
$\Rightarrow b\times x+(a-b\times \lfloor\frac{a}{b}\rfloor)\times y=gcd(a,b)$
$\Rightarrow a\times y+b\times (x-\lfloor\frac{a}{b}\rfloor\times y)=gcd(a,b)$
$\Rightarrow x_0=y,y_0=x-\lfloor\frac{a}{b}\rfloor\times y$
```C++
LL exgcd(LL a,LL b,LL &x,LL &y){
	if(!b){
		x = 1,y = 0;
		return a;
	}
	LL t = exgcd(b,a % b,y,x);
	y -= (a / b) * x;
	return t;
}
```
- 线性同余方程的通解
求解线性同余方程$ax \equiv b \pmod{p}$等价于求解线性不定方程$ax + py = b$的一组解，该方程有整数解的充要条件为 $\gcd(a,n) \mid b$。
应用扩展欧拉定理求得不定方程$ax + py = \gcd(a,p)$的一组解$x_0,y_0$，令$x = x_0 \times \frac{b}{\gcd(a,p)},y = y_0 \times \frac{b}{\gcd(a,p)}$得到方程的一组解。
若$x_0,y_0$为方程$ax + py = b$的一组解，则该方程的通解为$x = x_0 + k \times \frac{p}{\gcd(a,p)},y = y_0 - k \times \frac{a}{gcd(a,p)}$


**2. 费马小定理和欧拉定理**
- 费马小定理
$a^{p-1}\equiv 1\pmod{p}$ 当$p$是质数

- 欧拉定理
若$\gcd(a,m) = 1$，则$a^{\varphi(m)} \equiv 1 \pmod{m}$。

- 扩展欧拉定理
$$ 
a^b \equiv \begin{cases}
  a^{b \bmod \varphi(m)},                &\gcd(a,m) =  1,                   \\
  a^b,                                   &\gcd(a,m)\ne 1, b <   \varphi(m), \\
  a^{(b \bmod \varphi(m)) + \varphi(m)}, &\gcd(a,m)\ne 1, b \ge \varphi(m).
\end{cases} \pmod m$$


- 线性求逆元
$\displaystyle p = k\times i+r$
$\displaystyle \therefore k\times i+r\equiv 0\pmod{p}$
$\displaystyle 同乘i^{-1},r^{-1}得$
$\displaystyle k\times r^{-1}+i^{-1}\equiv 0\pmod{p}$
$\displaystyle i^{-1}\equiv -k\times r^{-1} \pmod{p}$
$\displaystyle i^{-1}\equiv (p-\lfloor\frac{p}{i}\rfloor)\times (p\%i)^{-1}\pmod{p}$
```C++
void get_inv(LL n,LL p){
	inv[1] = 1;
	for(int i = 2;i <= n;i++)inv[i] = (p - p / i) * inv[p % i] % p;
}
```
- 线性求阶乘的逆元
$\because n!\times x\equiv 1\pmod{p}$
$\therefore (n-1)!\times n\times x\equiv 1\pmod{p}$
$\therefore inv[n-1]=inv[n]\times n\%p$
```C++
void get_fac_inv(LL n,LL p){
	inv[n] = qmi(fac[n],p - 2,p);
	for(int i = n - 1;i >= 0;i--){
		inv[i] = inv[i + 1] * (i + 1) % p;
	}
}
```
**3. 线性筛法**
- 线性筛质数
```C++
void get_primes(int n){
    for(int i = 2;i <= n;i++){
        if(!st[i])primes[cnt++] = i;
        for(int j = 0;j < cnt && primes[j] <= n / i;j++){
            st[i * primes[j]] = true;
            if(i % primes[j] == 0)break;
        }
    }
}
```
>1e5范围内素数有9592个，1e6范围内素数有78498个
- 筛法求约数个数
	- $d(i)表示i的约数个数,pw(i)表示i的最小质因子的次数,m=i*p_j$
	- $\displaystyle 若n=\prod_{i=1}^sp_i^{\alpha_i},则d(n)=\prod_{i=1}^s(\alpha_i+1)$
	- $若i能被p_j整除,则p_j是m的最小质因子$
	$\displaystyle \therefore pw[m]=pw[i]+1,d[m]=\frac{d[i]}{pw[i]+1}\times (pw[m]+1)$
	- $若i不能被p_j整除,则i不包含质因子p_j$
	$\displaystyle \therefore pw[m]=1,d[m]=d[i]\times (pw[m]+1)=d[i]\times 2$

```C++
void get_d(int n){
    d[1] = 1;
    for(int i = 2;i <= n;i++){
        if(!st[i]){
            primes[cnt++] = i;
            pw[i] = 1,d[i] = 2;
        }
        for(int j = 0;j < cnt && primes[j] <= n / i;j++){
            int m = i * primes[j];
            st[m] = true;
            if(i % primes[j] == 0){
                pw[m] = pw[i] + 1;
                d[m] = d[i] / (pw[i] + 1) * (pw[m] + 1);
				break;
            }else{
                pw[m] = 1,d[m] = d[i] * 2; 
            }
        }
    }
}
```
- 筛法求约数和
	- $\displaystyle f(i)表示i的约数和,g(i)表示i的最小质因子的\sum_{i=0}^kp^i$
	- $\displaystyle 若n=\prod_{i=1}^sp_i^{\alpha_i},则f(n)=\prod_{i=1}^s\sum_{j=0}^{k_i}p_i^j$
	- $若i能被p_j整除,则p_j是m的最小质因子$
	$\therefore g[m]=g[i]\times p_j+1,f[m]=\frac{f[i]}{g[i]}\times g[m]$
	- $若i不能被p_j整除,则i不包含质因子p_j$
	$\therefore g[m]=1+p_j,f[m]=f[i]\times g[m]$
```C++
void get_f(int n){
    g[1] = f[1] = 1;
    for(int i = 2;i <= n;i++){
        if(!st[i]){
            primes[cnt++] = i;
            g[i] = f[i] = 1 + i;
        }
        for(int j = 0;j < cnt && primes[j] <= n / i;j++){
            int m = i * primes[j];
            st[m] = true;
            if(i % primes[j] == 0){
                g[m] = g[i] * primes[j] + 1;
                f[m] = f[i] / g[i] * g[m];
                break;
            }else{
                g[m] = primes[j] + 1;
                f[m] = f[i] * g[m];
            }
        }
    }
}
```
- 筛法求欧拉函数
	- $m=i\times p_j$
	- $若i能被p_j整除，则i包含了m的所有质因子\\$$\therefore\varphi(m)=p_j\times\varphi(i)$
	- $若i不能被p_j整除，则说明i和p_j互质\\$$\therefore\varphi(m)=\varphi(i)\times\varphi(p_j)$
```C++
void get_phi(int n){
    for(int i = 2;i <= n;i++){
        if(!st[i]){
            primes[cnt++] = i;
            phi[i] = i - 1;
        }
        for(int j = 0;j < cnt && primes[j] <= n / i;j++){
            int m = i * primes[j];
            st[m] = true;
            if(i % primes[j] == 0){
                phi[m] = primes[j] * phi[i];
                break;
            }else{
                phi[m] = phi[primes[j]] * phi[i];
            }
        }
    }
}
```
- 筛法求莫比乌斯函数
	- $若i是质数,则mu[i] = -1$
	- $若i能被p_j整除,则i也包含质因子p_j\\
	mu[m]=0$
	- $若i不能被p_j整除,则m比i多一个不同的质因子\\
	mn[m]=-mu[i]$
```C++
void get_f(int n){
    mu[1] = 1;
    for(int i = 2;i <= n;i++){
        if(!st[i]){
            primes[cnt++] = i;
            mu[i] = -1;
        }
        for(int j = 0;j < cnt && primes[j] <= n / i;j++){
            int m = i * primes[j];
            st[m] = true;
            if(i % primes[j] == 0){
                mu[i] = 0;
                break;
            }else{
                mu[m] = -mu[i];
            }
        }
    }
}
```  

**4. 中国剩余定理**
- 求解线性同余方程组
    $$\begin{cases}
        x \equiv r_1\pmod{m_1}\\
        x \equiv r_2\pmod{m_2}\\
        \cdots\\
        x \equiv r_n\pmod{m_n}
    \end{cases}
    $$
    $其中模数m_1,m_2,\cdots,m_n为两两互质的整数$
    $求x的最小非负整数解$
- 中国剩余定理(CRT)
    1. $\displaystyle 计算所有模数的积M$
    2. $\displaystyle 计算第i个方程的c_i=\frac{M}{m_i}$
    3. $\displaystyle 计算c_i在模m_i意义下的逆元c_i^{-1}$
    4. $\displaystyle x=\sum_{i=1}^{n}r_ic_ic_i^{-1}$
```C++
LL CRT(vector<int> &r,vector<int> &m,int n){
    LL res = 0,M = 1;
    for(int i = 1;i <= n;i++)M *= m[i];
    for(int i = 1;i <= n;i++){
        LL c = M / m[i],x,y;
        exgcd(c,m[i],x,y);
        res = (res + r[i] * c * x % M) % M;
    }
    return (res % M + M) % M; 
}
```
- 扩展中国剩余定理(EXCRT)
    $若模数m_1,m_2,\cdots,m_n为不一定两两互质的整数$
    $前两个方程:x\equiv r_1\pmod{m_1},x\equiv r_1\pmod{m_2}$
    $转化为不定方程:x=m_1\times p+r_1=m_2\times q+r_2$
    $由裴蜀定理$
    $当gcd(m_1,m_2)|(r_2-r_1)时有解$
    $由扩展欧几里得算法$
    $得特解p=p\times \frac{r_2-r_1}{gcd},q=q\times \frac{r_2-r_1}{gcd}$
    $其通解P=p+\frac{m2}{gcd}\times k,Q=q-\frac{m1}{gcd}\times k$
    $所以x=m_1\times P+r_1=\frac{m_1\times m_2}{gcd}\times k+m_1\times p+r_1$
    $前两个方程等价合并为一个方程x\equiv r\pmod{m}$
    $其中r=m_1\times p+r_1,m=lcm(m_1,m_2)$
    $所以n个同余方程只要合并n-1次即可求解$
```C++
LL EXCRT(vector<LL> &r,vector<LL> &m,int n){
    LL m1,m2,r1,r2,p,q;
    m1 = m[1],r1 = r[1];
    for(int i = 2;i <= n;i++){
        m2 = m[i],r2 = r[i];
        LL d = exgcd(m1,m2,p,q);
        if((r2 - r1) % d)return -1;
        p = p * (r2 - r1) / d;
        p = (p % (m2 / d) + m2 / d) % (m2 / d);
        r1 = m1 * p + r1;
        m1 = m1 * m2 / d;
    }
    return (r1 % m1 + m1) % m1;
}
```
**5. 欧拉函数**
- 定义
$欧拉函数，既\varphi(n)，表示小于等于n与n互质的正整数的个数$
- 性质
	1. $\displaystyle 当x是质数时,\varphi(n)=n-1$
	2. $\displaystyle 欧拉函数是积性函数，当gcd(a,b)=1，那么\varphi(a\times b)=\varphi(a)\times\varphi(b)$
	3. $\displaystyle 若n=p^k，其中p是质数，那么\varphi(n)=p^k-p^{k-1}$
	4. $\displaystyle 设n=\prod_{i=1}^{s}p_i^{k_i}，其中p_i是质数，有\varphi(n)=n\times\prod_{i=1}^{s}\frac{p_i-1}{p_i}$
	5. $\displaystyle \sum_{d|n}\varphi(d)=n$
- 求欧拉函数值
```C++
int phi(int n) {
	if(n == 1)return 0;
    int res = n;
    for (int i = 2; i * i <= n; i++)
        if (n % i == 0) {
        res = res / i * (i - 1);
        while (n % i == 0) n /= i;
        }
    if (n > 1) res = res / n * (n - 1);
    return res;
}
```
**6. 莫比乌斯函数**
- 定义
	$$\mu(n)=\begin{cases}
	1 && n=1\\
	0 && n含相同的质因子\\
	(-1)^s && s为不同的质因子个数
	\end{cases}$$
- 性质
   1. $莫比乌斯函数是积性函数，当gcd(a,b)=1，那么\mu(a*b)=\mu(a)*\mu(b)$
   2. $\displaystyle \sum_{d|n}\mu(d)=\varepsilon(n),既\mu*1=\varepsilon$
	$\displaystyle 证明：设n=\prod_{i=1}^kp_i^{\alpha_i},n^{'}=\prod_{i=1}^kp_i$
	$~~~~~~~~~~~~$$\displaystyle 那么\sum_{d|n}\mu(d)=\sum_{d|n^{'}}\mu(d)=\sum_{i=0}^{k}C_i^k\times (-1)^i	=(1+(-1))^k=0$

- 莫比乌斯反演
	1. $\displaystyle 若g(n)=\sum_{d|n}f(d),则f(n)=\sum_{d|n}\mu(d)g(\frac{n}{d})$
	$\displaystyle 数论变换证明:\sum_{d|n}\mu(d)g(\frac{n}{d})=\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}f(i)=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}\mu(d)=f(n)$
	$\displaystyle 卷积证明:原问题可化为:已知g=f*1,证明f=g*\mu$
	$\displaystyle g*\mu=f*1*\mu=f*\varepsilon=f$
	2. $若g(n)=\sum_{n|d}f(d),则f(n)=\sum_{n|d}\mu(\frac{d}{n})g(d)$
	$\displaystyle 数论变换证明:\sum_{n|d}\mu(\frac{d}{n})f(d)=\sum_{n|d}\mu(\frac{d}{n})\sum_{d|i}f(i)=\sum_{n|i}f(i)\sum_{d|\frac{i}{n}}\mu(d)=f(n)$

**7. 狄利克雷卷积**
- 定义
	$f(n),g(n)是两个数论函数$
	$(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})=\sum_{d|n}f(\frac{n}{d})g(d)$
- 规律
	- $交换律:f*g=g*f$
	- $结合律:(f*g)*h=f*(g*h)$
	- $分配律:(f+g)*h=f*h+g*h$
- 三个常用函数
	- $元函数:\varepsilon(n)=\begin{cases}
		1 && n=1\\
		0 && n\neq1\\
  		\end{cases}$
	- $常数函数:1(n)=1$
	- $恒等函数:id(n)=n$
- 常用卷积关系
	- $\sum_{d|n}\mu(d)=\varepsilon(n)\Leftrightarrow\mu*1=\varepsilon$
	- $\sum_{d|n}\varphi(d)=n\Leftrightarrow\varphi*1=id$
	- $\sum_{d|n}\mu(d)$<font size=5>$\frac{n}{d}$</font>$=\varphi(n)\Leftrightarrow\mu*id=\varphi$
	- $f*\varepsilon=f$
	- $[gcd(x,y)=1]=\sum_{d|gad(x,y)}\mu(d)$

**8. Miller_Rabin And Pollard Rho**
- 时间复杂度$O(n^{\frac{1}{4}})$
```C++
namespace Prime{
    static LL max_fac;
    static constexpr __int128 test[12] = {2,3,5,7,11,13,17,19,23,29,31,37};
    static __int128 qmi(__int128 a,__int128 k,__int128 p){
        __int128 res = 1;
        a = a % p;
        while(k){
            if(k & 1)res = res * a % p;
            a = a * a % p;
            k >>= 1;
        }
        return res;
    }
    static bool Miller_Rabin(__int128 p){
        if(p < 3 || p % 2 == 0)return p == 2;
        __int128 tem = p - 1,k = 0,next;
        while(tem % 2 == 0)tem >>= 1,k++;
        for(int i = 0;i < 12;i++){
            next = qmi(test[i],tem,p);
            if(next <= 1 || next == p - 1)continue;
            for(int j = 0;j < k;j++){
                next = next * next % p;
                if(next == p - 1 && j != k - 1){
                    next = 1;
                    break;
                }
                if(next == 1)return false;
            }
            if(next != 1)return false;
        }
        return true;
    }
    static LL Pollard_Rho(LL x){
        LL s = 0,t = 0,c,div,val = 1;
        int step = 0,goal = 1;
        c = (LL)rand() % (x - 1) + 1;
        for(goal = 1;;goal <<= 1,s = t,val = 1){
            for(step = 1;step <= goal;step++){
                t = ((__int128)t * t + c) % x;
                val = (__int128)val * abs(t - s) % x;
                if(step % 127 == 0){
                    div = __gcd(val,x);
                    if(div > 1)return div;
                }
            }
            div = __gcd(val,x);
            if(div > 1)return div;
        }
        return 0;
    }
    static void Get_Fac(LL x){
        if(x <= max_fac || x < 2)return;
        if(Miller_Rabin(x)){
            max_fac = max(max_fac,x);
            return;
        }
        LL p = x;
        while(p >= x)p = Pollard_Rho(x);
        while(x % p == 0)x /= p;
        Get_Fac(x),Get_Fac(p);
        return;
    }
    static LL Get_Max_Fac(LL x){
        srand(time(NULL));
        max_fac = 0;
        Get_Fac(x);
        return max_fac;
    }
};
```

**9.威尔逊定理**
- 对于素数$p$有$(p - 1)! \equiv -1 \pmod p$
- 对于除$4$以外的非素数$x$有$(x - 1)! \equiv 0 \pmod x$

**10.卢卡斯定理**
- 对于质数$p$，有
$$
\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p
$$

- 时间复杂度为$O(f(p) + g(n)\log n)$，其中$f(n)$为预处理组合数的复杂度，$g(n)$为单次求组合数的复杂度。

### <div id = "4.6">组合数学<div>
**1.隔板法**
- $n$个完全相同的元素分为$k$组，保证每组至少有一个元素$\displaystyle \binom{n - 1}{k - 1}$
- $n$个完全相同的元素分为$k$组，允许某些组别为空$\displaystyle \binom{n + k - 1}{k - 1}$
- $n$个完全相同的元素分为$k$组，要求第$i$组至少有$a_i$个元素$\displaystyle \binom{n - \sum{a_i} + k - 1}{k - 1}$
- $1 \sim n$这$n$个自然数中选$k$个，这$k$个数中任意两个不相邻$\displaystyle \binom{n - k + 1}{k}$

**2.圆排列**
- 从n个不同元素中选取m个围成一圈的圆排列数，记作$Q_n^m$
- $\displaystyle Q_n^n \times n = A_n^n$
- $\displaystyle Q_n^m = C_n^mQ_m^m = \frac{n!}{m(n - m)!}$

**3.错位排列**
- 错位排列是没有任何元素出现在其有序位置的排列。即对于$1 \sim n$的排列$P$，如果满足$P_i \neq i$，则称$P$是$n$的错位排列，记为$D_n$。
- $\displaystyle D_n = n! - n! \sum_{k=1}^n \frac{(-1)^{k-1}}{k!} = n! \sum_{k=0}^n \frac{(-1)^k}{k!}$
- 递推式：$D_n = (n - 1)(D_{n - 1} + D_{n - 2})$
- 边界：$D_1 = 0$，$D_2 = 1$

**4.第一类斯特林数**
- 将$n$个不同的元素，划分为$m$个非空圆排列的方案数，记作$s(n,m)$或$\begin{bmatrix}n\\ k\end{bmatrix}$
- 递推式：$\begin{bmatrix}n\\
  m\end{bmatrix}=\begin{bmatrix}n-1\\ 
  m-1\end{bmatrix}+(n-1)\begin{bmatrix}n-1\\ 
  m\end{bmatrix}$
- 边界：$\begin{bmatrix}n \\ 0\end{bmatrix} = [n = 0]$


**5.第二类斯特林数**
- 将$n$个不同元素，划分为$m$个非空子集的方案数，记作$S(n,m)$或$\begin{Bmatrix}n\\ m\end{Bmatrix}$
- 递推式：$\begin{Bmatrix}n\\ m\end{Bmatrix}=\begin{Bmatrix}n - 1\\ m - 1\end{Bmatrix} + m\begin{Bmatrix}n-1\\ m\end{Bmatrix}$
- 边界：$\begin{Bmatrix}n\\ 0\end{Bmatrix} = [n=0]$。
- 通项公式：$\begin{Bmatrix}n\\ m\end{Bmatrix}=\displaystyle \sum_{i = 0}^m\frac{(-1)^{m-i}i^n}{i!(m-i)!}$

**6.范德蒙德卷积**
$$
\sum_{i=0}^k\binom{n}{i}\binom{m}{k - i}=\binom{n + m}{k}
$$
若考虑其组合意义证明：
在一个大小为$n + m$的集合中取出$k$个数，可以等于把大小为$n + m$的集合拆成两个集合，大小分别为$n$与$m$，然后从$n$中取出$i$个数，从$m$中取出$k - i$个数的方案数。由于我们有了对于$i$的枚举，于是只需要考虑一种拆法，因为不同的拆法之间是等价的。
- 推论$1$
    $\displaystyle \sum_{i = -r}^{s}\binom{n}{r + i}\binom{m}{s - i}=\binom{n + m}{r + s}$
- 推论$2$
    $\displaystyle \sum_{i = 1}^{n}\binom{n}{i}\binom{n}{i - 1}=\binom{2n}{n-1}$
- 推论$3$
    $\displaystyle \sum_{i = 0}^{n}\binom{n}{i}^2=\binom{2n}{n}$
- 推论$4$
    $\displaystyle \sum_{i = 0}^{m}\binom{n}{i}\binom{m}{i}=\binom{n + m}{m}$

**7. 二项式反演**
- 至多转化为恰好
$$
\begin{align*}
& g(n) = \sum_{i = 0}^{n}\binom{n}{i}f(i) \iff f(n) = \sum_{i = 0}^{n}(-1)^{n - i}\binom{n}{i}g(i) \\
& g(n) = \sum_{i = 0}^{n}(-1)^{i}\binom{n}{i}f(i) \iff f(n) = \sum_{i = 0}^{n}(-1)^{i}\binom{n}{i}g(i) 
\end{align*}
$$

- 至少转化为恰好
$$
\begin{align*}
& g(n) = \sum_{i = n}^{N}\binom{i}{n}f(i) \iff f(n) = \sum_{i = n}^{N}(-1)^{i - n}\binom{i}{n}g(i) \\
& g(n) = \sum_{i = n}^{N}(-1)^{i}\binom{i}{n}f(i) \iff f(n) = \sum_{i = n}^{N}(-1)^{i}\binom{i}{n}g(i) 
\end{align*}
$$

**8. 卡特兰数**
- 前k项的值

| $H_0$ | $H_1$ | $H_2$ | $H_3$ | $H_4$ | $H_5$ | $H_6$ |
| --- | --- | --- | --- | --- | --- | --- |
| 1   | 1   | 2   | 5   | 14  | 42  | 132 |

- 常见公式
$$
\begin{align*}
    &H_n = \frac{\binom{2n}{n}}{n + 1} \\
    &H_n =  
        \begin{cases}
            \sum_{i = 1}^{n}H_{i - 1}H_{n - i}  &n \ge 2 \\
            1   & n = 0,1
        \end{cases} \\
    &H_n = \binom{2n}{n} - \binom{2n}{n - 1}
\end{align*}
$$

**9. 组合数公式**
- $\displaystyle \binom{n}{i} \binom{i}{m} = \binom{n}{m} \binom{n - m}{i - m}$

- $\displaystyle \sum_{i = 0}^{n}\binom{n}{i} \times x^i = (1 + x)^n$

- $\displaystyle \sum_{i = 0}^{n}\binom{n}{i} \times i = \frac{1}{2} \times (\sum_{i = 0}^{n}\binom{n}{i} \times i + \sum_{i = 0}^{n}\binom{n}{n - i} \times (n - i)) =  n \times 2^{n - 1}$

- $\displaystyle \sum_{i = m}^{n}\binom{i}{a} = \binom{n + 1}{a + 1} - {\binom{m}{a + 1}}$

- $\displaystyle \sum_{i = 0}^{n}\binom{n}{i}^{2} = \binom{2n}{n}$

- $\displaystyle \sum_{i = 0}^{m}\binom{n + i - 1}{i} = \binom{n + m}{m}$

### <div id = "4.7">多项式<div>
**1.快速傅里叶变换FFT**
- 递归实现
```C++
void FFT(Complex A[],int n,int op){
	if(n == 1)return;
	Complex A1[n / 2],A2[n / 2];
	for(int i = 0;i < n / 2;i++){
		A1[i] = A[2 * i];
		A2[i] = A[2 * i + 1];
	}
	FFT(A1,n / 2,op),FFT(A2,n / 2,op);
	Complex w1(cos(2 * PI / n),sin(2 * PI / n) * op);
	Complex wk(1,0);
	for(int i = 0;i < n / 2;i++){
		A[i] = A1[i] + A2[i] * wk;
		A[i + n / 2] = A1[i] - A2[i] * wk;
		wk = wk * w1;
	}
}
```
- 递推实现
```C++
void change(Complex A[],int n){
	int i,j,k;
    for(i = 1,j = n / 2;i < n - 1;i++){
        if (i < j)swap(A[i], A[j]);
        k = n / 2;
        while(j >= k) {
            j -= k;
            k /= 2;
        }
        if(j < k)j += k;
    }
}

void FFT(Complex A[],int n,int op){
	change(A,n);
	for(int m = 2;m <= n;m <<= 1){
		Complex w1(cos(2 * PI / m),sin(2 * PI / m) * op);
		for(int i = 0;i < n;i += m){
			Complex wk(1,0);
			for(int j = 0;j < m / 2;j++){
				Complex x = A[i + j],y = A[i + j + m / 2] * wk;
				A[i + j] = x + y;
				A[i + j + m / 2] = x - y;
				wk = wk * w1;
			}
		}
	}
}
```

- 用法
```C++
void solve(){
	int n,m;
	cin >> n >> m;
	for(int i = 0;i <= n;i++)cin >> A[i].x;
	for(int i = 0;i <= m;i++)cin >> B[i].x;
	for(m = n + m,n = 1;n <= m;n <<= 1);
	FFT(A,n,1),FFT(B,n,1);
	for(int i = 0;i < n;i++)A[i] = A[i] * B[i];
	FFT(A,n,-1);
	for(int i = 0;i <= m;i++){
		cout << LL(A[i].x / n + 0.5) << " ";
	}
	cout << endl;
} 
```

**2. 快速数论变换NTT**
- 阶的定义
若 $g$，$p$ 互质，使得 $g^n \equiv 1 \pmod{p}$ 的最小正整数 $n$ 称为 $g$ 模 $p$ 的阶。记作 $\delta_p(a)$
- 原根的定义
若 $\delta_p(g) = \varphi(p)$，则称 $g$ 为模 $p$ 的一个原根
- 模数的选择
模数 $p$ 选择形如 $q * 2^k + 1$ 的质数，其中 $q$ 为奇质数，$k$ 为整数

```C++
vector<int> rev;
const int g = 3,gi = 332748118;
// gi = g.inv()
void dft(vector<Z> &a,int op) {
    int n = a.size();
    
    if (int(rev.size()) != n) {
        int k = __builtin_ctz(n) - 1;
        rev.resize(n);
        for (int i = 0; i < n; i++) {
            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (rev[i] < i) {
            swap(a[i], a[rev[i]]);
        }
    }

    for(int i = 2;i <= n;i <<= 1){
        Z g1 = qmi(Z(op == 1 ? g : gi),(Z::getMod() - 1) / i);
        for(int j = 0;j < n;j += i){
            Z gk = 1;
            for(int k = j;k < j + i / 2;k++){
                Z x = a[k],y = gk * a[k + i / 2];
                a[k] = x + y;
                a[k + i / 2] = x - y;
                gk *= g1;
            }
        }
    }
}

struct Poly : public vector<Z>{
    Poly() : vector<Z>() {}
    Poly(int n) : vector<Z>(n) {}
    Poly(const vector<Z> &a) : vector<Z>(a) {}
    Poly(const initializer_list<Z> &a) : vector<Z>(a) {}

    Poly trunc(int k) const {
        Poly f = *this;
        f.resize(k);
        return f;
    }

    friend Poly operator+(const Poly &a,const Poly &b) {
        Poly res(max(a.size(), b.size()));
        for (int i = 0; i < a.size(); i++) {
            res[i] += a[i];
        }
        for (int i = 0; i < b.size(); i++) {
            res[i] += b[i];
        }
        return res;
    }
    friend Poly operator-(const Poly &a,const Poly &b) {
        Poly res(max(a.size(), b.size()));
        for (int i = 0; i < a.size(); i++) {
            res[i] += a[i];
        }
        for (int i = 0; i < b.size(); i++) {
            res[i] -= b[i];
        }
        return res;
    }
    friend Poly operator-(const Poly &a) {
        std::vector<Z> res(a.size());
        for (int i = 0; i < int(res.size()); i++) {
            res[i] = -a[i];
        }
        return Poly(res);
    }
    friend Poly operator*(Poly a,Poly b) {
        if (a.size() == 0 || b.size() == 0) {
            return Poly();
        }
        int n = 1, tot = a.size() + b.size() - 1;
        while (n < tot){
            n <<= 1;
        }
        a.resize(n);
        b.resize(n);
        dft(a,1);
        dft(b,1);
        for(int i = 0; i < n; ++i) {
            a[i] *= b[i];
        }
        dft(a,-1);
        Z inv = Z(n).inv();
        for(int i = 0;i < n;i++){
            a[i] *= inv;
        }
        a.resize(tot);
        return a;
    }
    friend Poly operator*(Z a,Poly b) {
        for (int i = 0; i < int(b.size()); i++) {
            b[i] *= a;
        }
        return b;
    }
    friend Poly operator*(Poly a,Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] *= b;
        }
        return a;
    }
    friend Poly operator/(Poly a,Z b) {
        for (int i = 0; i < int(a.size()); i++) {
            a[i] /= b;
        }
        return a;
    }
    Poly &operator+=(Poly b) {
        return (*this) = (*this) + b;
    }
    Poly &operator-=(Poly b) {
        return (*this) = (*this) - b;
    }
    Poly &operator*=(Poly b) {
        return (*this) = (*this) * b;
    }
    Poly &operator*=(Z b) {
        return (*this) = (*this) * b;
    }
    Poly &operator/=(Z b) {
        return (*this) = (*this) / b;
    }
    Poly inv(int m) const {
        // F(x) * G(x) = 1 (mod x^m)
        Poly x{(*this)[0].inv()};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{2} - trunc(k) * x)).trunc(k);
        }
        return x.trunc(m);  
    }
	Poly deriv() const {
        if(this->empty()){
            return Poly();
        }
        Poly res(this->size() - 1);
        for (int i = 0;i < this->size() - 1;++i) {
            res[i] = (i + 1) * (*this)[i + 1];
        }
        return res;
    }
    Poly integr() const {
        Poly res(this->size() + 1);
        for (int i = 0; i < this->size(); ++i) {
            res[i + 1] = (*this)[i] / (i + 1);
        }
        return res;
    }
	Poly log(int m) const {
		// 当x[0]f(x) = 1时，f(x)有对数多项式
        return (deriv() * inv(m)).integr().trunc(m);
    }
	Poly exp(int m) const {
        Poly x{1};
        int k = 1;
        while (k < m) {
            k *= 2;
            x = (x * (Poly{1} - x.log(k) + trunc(k))).trunc(k);
        }
        return x.trunc(m);
    }
    Poly pow(LL k,int n){
        // x[0]f(x) = 1时直接使用
        // 否则化为 (w * x^t)^k * f`(x)^k
        return (log(n) * Z(k)).exp(n);
    }
};
```

### <div id = "4.8">线性基<div>

```C++
struct Basis{
    const static int m = 63;
    int sz;
    bool zero,wk;
    array<LL,m> p;
    Basis() : p{},zero(false),wk(false),sz(0) {}

    void work(){
        if(wk)return;
        for(int i = m - 1;i >= 0;i--){
            for(int j = i - 1;j >= 0;j--){
                if(p[i] >> j & 1)p[i] ^= p[j];
            }
        }
        wk = true;
    }
    bool insert(LL x){
        for(int i = m - 1;i >= 0;i--){
            if((x >> i & 1) == 0)continue;
            if(!p[i]){
                p[i] = x;
                sz++;
                wk = false;
                return true;
            }
            x ^= p[i];
        }
        zero = true;
        return false;
    }
    LL max_xor(){
        LL x = 0;
        for(int i = m - 1;i >= 0;i--){
            if((x ^ p[i]) > x)x ^= p[i];
        }
        return x;
    }
    LL kth(LL k){
        work();
        if(zero)k--;
        if(k >= (1LL << sz))return -1;
        vector<LL> w;
        for(int i = 0;i <= m - 1;i++){
            if(p[i])w.push_back(p[i]);
        }
        LL res = 0;
        for(int i = m - 1;i >= 0;i--){
            if(k >> i & 1)res ^= w[i];
        }
        return res;
    }
    LL size(){
        return sz;
    }
};
```

### <div id = "4.9">博弈论<div>
**1. 必胜必败态**

定义必胜态为先手必胜状态，必败态为先手必败状态。
- 定理1：没有后继状态的为必败态
- 定理2：一个状态是必胜态当且仅当至少存在一个必败态为它的后继状态
- 定理3：一个状态是必败态当且仅当它的所有后继状态都是必胜态

**2. 有向图游戏和SG函数**

在一个有向无环图中，只有一个起点，上面有一个棋子，两名玩家轮流沿着有向边推动棋子，不能走的玩家判负。
- 定义$mex(S)$为不属于集合$S$中的最小非负整数
- 对于状态$x$和它的所有$k$个后继状态$y_1,y_2,\ldots y_k$，定义SG函数：
$$
SG(x) = mex\{SG(y_1),SG(y_2),\ldots ,SG(y_k)\}
$$
- 对于由$n$个有向图游戏组成的组合游戏，设它们的起点分别为$s_1,s_2,\ldots s_n$，则由$SG$定理：当且仅当$SG(s_1) \oplus SG(s_2)\oplus \ldots \oplus SG(s_n) \neq 0$时，这个游戏是先手必胜的。同时，这是一个组合游戏的游戏状态$x$的$SG$值。

**3. Nim游戏和反Nim游戏**

**4. 无向图删边游戏**

**5. 二分图博弈**

### <div id = "4.10">其他<div>
- 哥德巴赫猜想
    任何一个大于$4$的偶数都能分解成$2$个质数的和  
    任何一个大于$5$的奇数都能分解成$3$个质数的和
    任何一个偶数都能表示成$2$个质数的差
- 分数的循环数位性质
    $\displaystyle \frac{p}{q}$为最简分数在$m$进制下,若$q$的质因数和$m$的质因数完全相同,则$\displaystyle \frac{p}{q}$是有限小数
    若$cnt2$,$cnt5$分别为$q$中质因子$2$的个数和质因子$5$的个数,那么$max(cnt2,cnt5)$为循环节之前部分小数的长度
    $\displaystyle 10^x\equiv 1\pmod{q}$的最小正整数解就是$\displaystyle \frac{p}{q}$的循环节长度


## <div id = "5"><center>计算几何</center><div>

### <div id = "5.1">计算几何模板<div>

```C++
using Point_t = double;
constexpr Point_t pi = 3.1415926535897932384l;
constexpr Point_t eps=1e-8;

template<typename T>
struct Point{
    T x,y;

    bool operator==(const Point &a) const {return (abs(x - a.x) <= eps && abs(y - a.y) <= eps);}
    bool operator<(const Point &a) const {return abs(x - a.x) <= eps ? y < a.y - eps : x < a.x - eps;}
    bool operator>(const Point &a) const {return !(*this < a || *this == a);}
    Point operator+(const Point &a) const {return {x + a.x,y + a.y};}
    Point operator-(const Point &a) const {return {x - a.x,y - a.y};}
    Point operator-() const {return {-x,-y};}
    Point operator*(const T k) const {return {k * x,k * y};}
    Point operator/(const T k) const {return {x / k,y / k};}
    T operator*(const Point &a) const {return x * a.x + y * a.y;}
    T operator^(const Point &a) const {return x * a.y - y * a.x;}
    int toleft(const Point &a) const {const auto t = (*this) ^ a; return (t > eps) - (t < -eps);}
    T len2() const {return (*this) * (*this);}
    T dis2(const Point &a) const {return (a - (*this)).len2();}

    Point_t len() const {return sqrt(len2());}
    Point_t dis(const Point &a) const {return sqrt(dis2(a));}
    Point_t ang(const Point &a) const {return acos(max(-1.0,min(1.0l,((*this) * a) / (len() * a.len()))));}  // 向量夹角
    Point rot(const Point_t rad) const {return {x * cos(rad) - y * sin(rad),x * sin(rad) + y * cos(rad)};}  // 逆时针旋转（给定角度）
    Point rot(const Point_t cosr,const Point_t sinr) const {return {x * cosr - y * sinr,x * sinr + y * cosr};}  // 逆时针旋转（给定角度的正弦与余弦）

};

template<typename T>
struct argcmp{
    bool operator()(const Point<T> &a,const Point<T> &b) const {
        const auto quad = [](const Point<T> &a){
            if(a.y < -eps)return 1;
            if(a.y > eps)return 4;
            if(a.x < -eps)return 5;
            if(a.x > eps)return 3;
            return 2;
        };
        const int qa = quad(a),qb = quad(b);
        if(qa != qb)return qa < qb;
        const auto t = a ^ b;
        return t > eps;
    }
};

template<typename T>
struct Line{
    Point<T> p,v;

    bool operator==(const Line &a) const {return v.toleft(a.v) == 0 && v.toleft(p - a.p) == 0;}
    int toleft(const Point<T> &a) const {return v.toleft(a - p);}
    bool operator<(const Line &a) const {
        // 半平面交算法定义的排序
        if(abs(v ^ a.v) <= eps && v * a.v >= -eps)return toleft(a.p) == -1;
        return argcmp<T>()(v,a.v);
    }

    Point<T> inter(const Line &a) const {return p + v * ((a.v ^ (p - a.p)) / (v ^ a.v));}  // 直线交点
    Point_t dis(const Point<T> &a) const {return abs(v ^ (a - p)) / v.len();}  // 点到直线距离
    Point<T> proj(const Point<T> &a) const {return p + v * ((v * (a - p)) /  (v * v));}  // 点在直线上的投影
};

template<typename T>
struct Segment{
    Point<T> a,b;

    bool operator<(const Segment &s) const {return make_pair(a,b) < make_pair(s.a,s.b);}

    // 判断点是否在线段上
    // -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上
    int is_on(const Point<T> &p) const {
        if(p == a || p == b) return -1;
        return (p - a).toleft(p - b) == 0 && (p - a) * (p - b) < -eps;
    }
    // 判断线段直线是否相交
    // -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
    int is_inter(const Line<T> &l) const {
        if (l.toleft(a) == 0 || l.toleft(b) == 0) return -1;
        return l.toleft(a) != l.toleft(b);
    }
    // 判断两线段是否相交
    // -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
    int is_inter(const Segment<T> &s) const {
        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b))return -1;
        const Line<T> l{a,b - a},ls{s.a,s.b - s.a};
        return l.toleft(s.a) * l.toleft(s.b) == -1 && ls.toleft(a) * ls.toleft(b) == -1;
    }
    // 点到线段距离
    Point_t dis(const Point<T> &p) const {
        if ((p - a) * (b - a) < -eps || (p - b) * (a - b) < -eps)return min(p.dis(a),p.dis(b));
        const Line<T> l{a,b-a};
        return l.dis(p);
    }
    // 两线段间距离
    Point_t dis(const Segment<T> &s) const {
        if (is_inter(s)) return 0;
        return min({dis(s.a),dis(s.b),s.dis(a),s.dis(b)});
    }
};

// 多边形面积的两倍
// 可用于判断点的存储顺序是顺时针或逆时针
template<typename T>
T area(const vector<Point<T>> &a) {
    int n = a.size();
    T sum = 0;
    for(int i = 0;i < n;i++)sum += a[i] ^ a[(i + 1) % n];
    return sum;
}

// 多边形的周长
template<typename T>
Point_t circ(const vector<Point<T>> &a) {
    int n = a.size();
    Point_t sum = 0;
    for(int i = 0;i < n;i++)sum += a[i].dis(a[(i + 1) % n]);
    return sum;
}

// 回转数
// 返回值第一项表示点是否在多边形边上
// 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内
template<typename T>
pair<bool,int> winding(const vector<Point<T>> &p,const Point<T> &a) {
    int n = p.size();
    int cnt = 0;
    for(size_t i = 0;i < p.size();i++){
        const Point<T> u = p[i],v = p[(i + 1) % n];
        if(abs((a - u) ^ (a - v)) <= eps && (a - u) * (a - v) <= eps)return {true,0};
        if(abs(u.y - v.y) <= eps)continue;
        const Line<T> uv = {u,v - u};
        if(u.y < v.y - eps && uv.toleft(a) <= 0)continue;
        if(u.y > v.y + eps && uv.toleft(a) >= 0)continue;
        if(u.y < a.y - eps && v.y >= a.y - eps)cnt++;
        if(u.y >= a.y - eps && v.y < a.y - eps)cnt--;
    }
    return {false,cnt};
}

// 点集的凸包
// Andrew 算法，复杂度 O(nlogn)
template<typename T>
vector<Point<T>> Andrew(vector<Point<T>> a){
    int tot = -1;
    int n = a.size();
    sort(a.begin(),a.end());
    vector<Point<T>> s;
    for(int i = 0;i < n;i++){
        while(tot >= 1 && ((s[tot] - s[tot - 1]).toleft(a[i] - s[tot - 1])) <= 0){
            tot--;
            s.pop_back();
        }
        s.push_back(a[i]);
        ++tot;
    }
    int t = tot;
    for(int i = n - 2;i >= 0;i--){
        while(tot > t && ((s[tot] - s[tot - 1]).toleft(a[i] - s[tot - 1])) <= 0){
            tot--;
            s.pop_back();
        }
        s.push_back(a[i]);
        ++tot;
    }
    s.pop_back();
    return s;
}

// 判断点是否在凸多边形内
// 复杂度 O(logn)
// -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内
template<typename T>
int is_in(const vector<Point<T>> &p,const Point<T> &a) {
    if(p.size() == 1)return a == p[0] ? -1 : 0;
    if(p.size() == 2)return Segment<T>{p[0],p[1]}.is_on(a) ? -1 : 0; 
    if(a == p[0])return -1;
    if((p[1] - p[0]).toleft(a - p[0]) == -1 || (p.back() - p[0]).toleft(a - p[0]) == 1)return 0;
    const auto cmp = [&](const Point<T> &u,const Point<T> &v){
        return (u - p[0]).toleft(v - p[0]) == 1;
    };
    const size_t i = lower_bound(p.begin() + 1,p.end(),a,cmp) - p.begin();
    if(i == 1)return Segment<T>{p[0],p[i]}.is_on(a) ? -1 : 0;
    if(i == p.size() - 1 && Segment<T>{p[0],p[i]}.is_on(a))return -1;
    if(Segment<T>{p[i-1],p[i]}.is_on(a))return -1;
    return (p[i] - p[i-1]).toleft(a - p[i-1]) > 0;
}
```

### <div id = "5.2">旋转卡壳<div>
- 凸包直径
```C++
for(int i = 1,j = 2;i <= n;i++){
    while(((a[i % n + 1] - a[i]) ^ (a[j] - a[i])) < ((a[i % n + 1] - a[i]) ^ (a[j % n + 1] - a[i])))j = j % n + 1;
    res = max({res,dist(a[i],a[j]),dist(a[i % n + 1],a[j])});
}
```
- 凸包的最小矩形覆盖
```C++
for(int i = 1,x = y = 2;i <= n;i++){
    while(((a[i % n + 1] - a[i]) ^ (a[x] - a[i])) < ((a[i % n + 1] - a[i]) ^ (a[x % n + 1] - a[i])))x = x % n + 1;
    if(i == 1)z = x;
    while((a[i % n + 1] - a[i]) * (a[y] - a[i]) < (a[i % n + 1] - a[i]) * (a[y % n + 1] - a[i]))y = y % n + 1;
    while((a[i] - a[i % n + 1]) * (a[z] - a[i % n + 1]) < (a[i] - a[i % n + 1]) * (a[z % n + 1] - a[i % n + 1]))z = z % n + 1;
    double d = sqrt(dist(a[i],a[i % n + 1]));
    double h = ((a[i % n + 1] - a[i]) ^ (a[x] - a[i])) / d;
    double r = (a[i % n + 1] - a[i]) * (a[y] - a[i]) / d;
    double l = (a[i] - a[i % n + 1]) * (a[z] - a[i % n + 1]) / d;
    if(res > (l + r - d) * h){
        res = (l + r - d) * h;
        ans[0] = a[i % n + 1] + (a[i] - a[i % n + 1]) * (l / d);
        ans[1] = a[i] + (a[i % n + 1] - a[i]) * (r / d);
        ans[2] = ans[1] + rotate(a[i % n + 1] - a[i],pi / 2) * (h / d);
        ans[3] = ans[0] + rotate(a[i % n + 1] - a[i],pi / 2) * (h / d);
    }
}
```
## <div id = "6"><center>杂项</center><div>
### <div id = "6.1">莫队<div>
**1. 普通莫队**
- 时间复杂度$O(n^{\frac{3}{2}})$
```C++
int B = sqrt(n);
sort(qry.begin() + 1,qry.end(),[&](array<int,3> a,array<int,3> b)->bool{
    if((a[0] - 1) / B == (b[0] - 1) / B)return (a[0] - 1) / B % 2 ? a[1] < b[1] : a[1] > b[1];
    else return (a[0] - 1) / B < (b[0] - 1) / B;
});

auto add = [&](int i)->void{

};
auto del = [&](int i)->void{

};

int l = 1,r = 0;
for(int i = 1;i <= q;i++){
    while(l > qry[i][0])add(--l);
    while(r < qry[i][1])add(++r);
    while(l < qry[i][0])del(l++);
    while(r > qry[i][1])del(r--);

}
```
**2. 带修莫队**
- 时间复杂度$O(n^{\frac{5}{3}})$
```C++
int B = pow(n,0.66666);
sort(qry.begin(),qry.end(),[&](array<int,4> a,array<int,4> b)->bool{
    if((a[0] - 1) / B == (b[0] - 1) / B){
        if((a[1] - 1) / B == (b[1] - 1) / B){
            return a[2] < b[2];
        }else{
            return (a[1] - 1) / B < (b[1] - 1) / B;
        }
    }else{
        return (a[0] - 1) / B < (b[0] - 1) / B;
    }
});

auto add = [&](int i)->void{

};
auto del = [&](int i)->void{

};

int l = 1,r = 0,t = -1;
for(int i = 0;i < m;i++){
    while(l > qry[i][0])add(--l);
    while(r < qry[i][1])add(++r);
    while(l < qry[i][0])del(l++);
    while(r > qry[i][1])del(r--);
    while(t < qry[i][2]){
        int p = upd[++t].first;
        if(l <= p && p <= r){
            del(p);
            swap(a[p],upd[t].second);
            add(p);
        }else{
            swap(a[p],upd[t].second);
        }
    }
    while(t > qry[i][2]){
        int p = upd[t].first;
        if(l <= p && p <= r){
            del(p);
            swap(a[p],upd[t].second);
            add(p);
        }else{
            swap(a[p],upd[t].second);
        }
        t--;
    }
}
```

### <div id = "6.2">CDQ分治<div>
- 三维偏序
```C++
int n,m;

struct BIT{
    int n;
    vector<LL> tr;
    BIT(int n = 0):n(n){tr = vector<LL>(n + 1);}
	void resize(int m){n = m,tr.resize(m + 1);}
    inline int lowbit(int x){return x & -x;}
    void modifly(int x,LL y){for(;x <= n;x += lowbit(x))tr[x] +=y;}
    LL query(int x){
        LL res = 0;
        for(;x;x -= lowbit(x))res += tr[x];
        return res;
    }
    LL query(int l,int r){
        LL res = 0;
        l--;
        for(;r;r -= lowbit(r))res += tr[r];
        for(;l;l -= lowbit(l))res -= tr[l];
        return res;
    }
}tr;

struct Tuple{
	int x,y,z,cnt,ans;
	bool operator ==(const Tuple a){
		return x == a.x && y == a.y && z == a.z;
	}
};

bool cmp1(Tuple a,Tuple b){
	if(a.x == b.x){
		if(a.y == b.y)return a.z < b.z;
		return a.y < b.y;
	}
	return a.x < b.x;
}

bool cmp2(Tuple a,Tuple b){
	if(a.y == b.y)return a.z < b.z;
	return a.y < b.y;
}

void CDQ(int l,int r,vector<Tuple> &a){
	if(l == r)return;
	int mid = (l + r) >> 1;
	CDQ(l,mid,a),CDQ(mid + 1,r,a);
	sort(a.begin() + l,a.begin() + mid + 1,cmp2);
	sort(a.begin() + mid + 1,a.begin() + r + 1,cmp2);
	int i = mid + 1,j = l;
	for(;i <= r;i++){
		while(j <= mid && a[j].y <= a[i].y){
			tr.modifly(a[j].z,a[j].cnt);
			j++;
		}
		a[i].ans += tr.query(a[i].z);
	}
	for(i = l;i < j;i++)tr.modifly(a[i].z,-a[i].cnt);
}

void solve(){
	cin >> n >> m;
	vector<Tuple> a(1),b(n + 1);
	for(int i = 1;i <= n;i++)cin >> b[i].x >> b[i].y >> b[i].z;
	sort(b.begin() + 1,b.end(),cmp1);
	for(int i = 1;i <= n;i++){
		int t = 1;
		while(i + 1 <= n && b[i + 1] == b[i])i++,t++;
		a.push_back({b[i].x,b[i].y,b[i].z,t,0});
	}
	tr.resize(m);
	CDQ(1,a.size() - 1,a);
	vector<int> cnt(n);
	for(int i = 1;i < a.size();i++)cnt[a[i].ans + a[i].cnt - 1] += a[i].cnt;
	for(int i = 0;i < n;i++)cout << cnt[i] << endl;
}
```
### <div id = "6.3">闵可夫斯基和优化dp<div>
- 用于优化 $(max/min,+)$ 卷积，形如$f_i = \max_{j = 0}^{i} / \min_{j = 0}^{i} g_j + h_{i - j}$，要求 $g$，$h$ 具有凸性
以 $max$ 为例，要求 $g$，$h$ 形成上凸包，对 $g$，$h$ 进行差分，那么 $f_i$ 相当于在 $\Delta g$ 和 $\Delta h$ 中选取两个前缀，要求长度和为 $i$，权值和最大。由于 $\Delta g$ 和 $\Delta h$ 都单调不升，那么归并后选前 $i$ 个数最优
同理 $min$ 要求 $g$，$h$ 形成下凸包
